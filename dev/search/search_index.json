{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Game Save Backups","text":"<p>A tool for managing incremental backups of your save states using Git!</p>"},{"location":"#in-a-nutshell","title":"In a Nutshell","text":"<p>Does Steam keep corrupting your cloud saves?</p> <p>Does it take too long to create or restore a Minecraft backup?</p> <p>Do you want to rewind your game five hours and explore what might have been if only you'd punched that NPC in the face?</p> <p>If that sounds like you, then <code>gsb</code> is here to help! This is a lightweight wrapper around the Git version control system that's optimized for game saves. Features (will) include:</p> <ul> <li>automated incremental backups</li> <li>painless savegame restores</li> <li>easy history navigation</li> <li>revision history compression and cleaning</li> <li>support for branches</li> <li>workflows for implementing 3-2-1 backups</li> <li>full compatibility with Git and other git-based tools...</li> <li>... all without ever needing to know a thing about Git</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The <code>gsb</code> package is written for Python 3.11 but otherwise should run on any operating system and architecture.</p> <p>The latest release can be installed from PyPI via <code>pip</code>:</p> <pre><code>$ python -m pip install --user gsb\n</code></pre> <p>Full installation instructions can be found on GitHub Pages.</p>"},{"location":"#usage","title":"Usage","text":"<p>The recommended way to interact with <code>gsb</code> is via its  command-line interface. Once you've installed the package, run the following command to get an overview of the available actions:</p> <pre><code>$ gsb --help\n</code></pre> <p>and use:</p> <p><pre><code>$ gsb &lt;verb&gt; --help\n</code></pre> (e.g. <code>gsb backup --help</code>)</p> <p>for further details on running each of those commands.</p> <p>Full documentation, including tutorials, examples and full CLI docs, can be found on GitHub Pages.</p>"},{"location":"#quick-start-guide","title":"Quick-Start Guide","text":"<p>Coming soon!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you're interested in helping develop this project, have a look at the repo backlog and then read through the contributor's guide.</p>"},{"location":"#license","title":"License","text":"<p>This project--the executable, source code and all documentation--are published under the GNU Public License v3, and any contributions to or derivatives of this project must be licensed under compatible terms.</p>"},{"location":"about/","title":"About <code>gsb</code>","text":"<p>Coming soon!</p>"},{"location":"cli/","title":"Full Command-Line Interface Documentation","text":""},{"location":"cli/#gsb","title":"gsb","text":"<p>CLI for managing incremental backups of your save states using Git!</p> <p>Usage:</p> <pre><code>gsb [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  -h, --help         Show this message and exit.\n  -v, -V, --version  Show the version and exit.\n</code></pre>"},{"location":"cli/#backup","title":"backup","text":"<p>Create a new backup.</p> <p>Usage:</p> <pre><code>gsb backup [OPTIONS] [SAVE_PATH]\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet       Decrease the amount of information that's printed.\n  -v, --verbose     Increase the amount of information that's printed.\n  --path SAVE_PATH  Optionally specify the root directory containing your save\n                    data. If no path is given, the current working directory\n                    will be used.\n  --tag \"MESSAGE\"   Specify a description for this backup and \"tag\" it for\n                    future reference.\n  --help            Show this message and exit.\n</code></pre>"},{"location":"cli/#history","title":"history","text":"<p>List the available backups, starting with the most recent.</p> <p>Usage:</p> <pre><code>gsb history [OPTIONS] [SAVE_PATH]\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet                     Decrease the amount of information that's\n                                  printed.\n  -v, --verbose                   Increase the amount of information that's\n                                  printed.\n  --path SAVE_PATH                Optionally specify the root directory\n                                  containing your save data. If no path is\n                                  given, the current working directory will be\n                                  used.\n  -n, --limit INTEGER             The maximum number of backups to return.\n  --since [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]\n                                  Only show backups created after the\n                                  specified date.\n  -a, --all                       Include non-tagged commits.\n  -g, --include_non_gsb           Include backups created directly with Git /\n                                  outside of gsb.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#init","title":"init","text":"<p>Start tracking a save.</p> <p>Usage:</p> <pre><code>gsb init [OPTIONS] [TRACK_PATTERN]...\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet       Decrease the amount of information that's printed.\n  -v, --verbose     Increase the amount of information that's printed.\n  --path SAVE_PATH  Optionally specify the root directory containing your save\n                    data. If no path is given, the current working directory\n                    will be used.\n  --track TEXT      Provide a glob pattern to track (note: arguments without\n                    any flag will also be treated as track patterns).\n  --ignore TEXT     Provide a glob pattern to ignore. Each ignore pattern must\n                    be prefaced with the \"--ignore\" flag.\n  --help            Show this message and exit.\n</code></pre>"},{"location":"cli/#rewind","title":"rewind","text":"<p>Restore a backup to the specified REVISION.</p> <p>Usage:</p> <pre><code>gsb rewind [OPTIONS] [REVISION]\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet             Decrease the amount of information that's printed.\n  -v, --verbose           Increase the amount of information that's printed.\n  --path SAVE_PATH        Optionally specify the root directory containing\n                          your save data. If no path is given, the current\n                          working directory will be used.\n  --include_gsb_settings  Also revert the GSB configuration files (including\n                          .gitignore)\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"contrib/","title":"Contribution Guide","text":"<p>The <code>gsb</code> package  is an open source project, and its source code is publicly available on GitHub.</p> <p>Please open a new issue to report a bug or to propose a new feature or enhancement.</p> <p>If you would like to contribute your own bugfixes or code enhancements, start by forking this repo, and cloning it into your local workspace.</p> <p>Note</p> <p>Note that all work should be done off of the <code>dev</code> branch</p>"},{"location":"contrib/#setting-up-a-development-environment","title":"Setting up a Development Environment","text":"<p>The development environment for this package is managed using conda. If you don't have one already, I highly recommend using a conda-forge-based distribution, such as mambaforge.</p> <p>Once you have conda installed and your fork cloned to your local workspace, navigate to that workspace and:</p> <ol> <li>Create the development environment via    <pre><code>mamba env create\n</code></pre>    (substitute <code>conda</code> if you so choose)</li> <li>Activate the development environment:    <pre><code>conda activate gsb\n</code></pre></li> <li>Install the package in editable mode:    <pre><code>python -m pip install --user -e .[test]\n</code></pre></li> <li>Set up pre-commit:    <pre><code>pre-commit install\n</code></pre></li> </ol> <p>Once that's done, start developing! Pre-commit is a fantastic tool that will take care of most style-guide enforcement for you, but details are below.</p>"},{"location":"contrib/#style-guide","title":"Style Guide","text":"<p>This package follows the standard Python style guides, most notably PEP8, targeting the Python 3.10 feature set. The one exception is that the line length maximum is set to 88, not 79. All non-trivial and \"public\" functions must have docstrings in the NumPy style.</p> <p>All code should be fully type-hinted, leveraging the latest changes introduced to the language. Favor use of <code>| None</code> \u2705 instead of <code>Optional</code> \u274c and built-in types (<code>list</code>, <code>tuple</code> \u2705) over their capitalized types (<code>from typing import List, Tuple</code> \u274c).</p> Type Hinting Pro Tip <p>A good practice to follow when using type hints is to make your return hints as specific and explicit as possible while making your parameter hints as broad as the function will allow. For example: <pre><code>from typing import Any, Collection\ndef stringify_dedupe_and_sort(sort_me: Collection[Any]) -&gt; list[str]:\n\"\"\"Take a collection of stuff, turn them all into strings, remove\n    any duplicates, and then return the results sorted in alphabetical\n    (lexical?) order\n    Parameters\n    ----------\n    sort_me : list-like\n        The things you want to sort\n    Returns\n    -------\n    list of str\n        The stringified, deduped and sorted items\n    Notes\n    -----\n    @ me if you want to see this implemented via a one-line comprehension!\n    \"\"\"\nreturn_me: list[str] = []\nfor value in sort_me:\nstringified: str = str(value)\nfor i, existing_value in enumerate(return_me):\nif existing_value &gt; stringified:\nreturn_me.insert(i, stringified)\nbreak\nelif existing_value == stringified:\nbreak\nelse:\npass\nelse:\nreturn_me.append(stringified)\nreturn return_me\n</code></pre> In the above, <code>sort_me</code> could be a list of strings, a set of <code>Path</code>s, or really any group of objects that you can iteratethrough and that has a defined length (and even that isn't even technically a requirement). Meanwhile on the output side, you're defining right off the bat that <code>return_me</code> is going to be a list and then enforcing that every member will be a string.</p> <p>There are a variety of other style conventions, especially around non-Python files, but they will be automatically enforced by pre-commit.</p>"},{"location":"contrib/#unit-testing","title":"Unit Testing","text":"<p>While unit tests are not globally required, any PR will require validation that the changes introduced are performing as intended (see below), and unit tests are a great way to provide that, especially given that <code>gsb</code> is meant to run across a wide variety of platforms. This package uses py.test as its test runner, and a wide variety of testing utililities and fixtures are available for you to leverage for help mocking out file systems.</p>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>In addition to internal (docstring) documentation, <code>gsb</code> includes HTML documentation hosted on GitHub Pages. This includes the static guides (that you are literally reading right now) as well as dynamically-generated HTML docs.</p> <p>The tool that performs this magic is called MkDocs and is included in the <code>gsb</code> development environment. One of MkDocs' killer] features is its ability to quickly render and serve the documentation locally. To do this, navigate your terminal to the repo root, activate your <code>gsb</code> environment and run the command:</p> <pre><code>mkdocs serve\n</code></pre> <p>and the terminal will soon contain a link (typically to http://127.0.0.1:8000/) where you can preview the documentation.</p> <p>When developing <code>gsb</code>, you should both check the compiled API docs based on your docstrings (and changes to the CLI) to ensure that everything is rendering as it should.</p>"},{"location":"contrib/#development-workflow","title":"Development Workflow","text":"<p>Development of <code>gsb</code> follows Gitflow, with all development done on feature-branches created off the <code>dev</code> branch.</p> <p>Once a significant number of changes have been merged into <code>dev</code> (usually the culmination of a milestone), a staging branch will be created off of <code>dev</code>, and a PR will be opened targeting merging changes from that branch into <code>release</code>. This process is typically accompanied by the creation of release candidate versions which are built and uploaded to PyPI for pre-release testing. During this phase, changes will be made directly to the staging branch to fix any bugs or regressions that come up during testing.</p> <p>Once it's time to cut a release,</p> <ol> <li>The staging PR will be merged into <code>release</code>.</li> <li> <p>A new release will    be created targeting the <code>release</code> branch and with a tag of the form    <code>v0.x.y</code>. The release notes should highlight the    significant changes in the new version, and the auto-generated release notes    should be modified to cover the period from the last full release    (as opposed to just the last release candidate).</p> <p>Tip</p> <p>Create draft release notes when cutting the first release candidate so that you can just copy them into the full release</p> </li> <li> <p>Cutting the new release will automatically push a new package build to    pypi and    update the docs.</p> </li> <li>Once the release is complete, the <code>dev</code> branch must be rebased on top of    <code>release</code>. This serves two goals:    - it applies any changes committed directly to the staging branch to <code>dev</code>    - it keeps the commit history linear (and makes it much easier to calculate)      the number of commits in <code>dev</code> since the last release.</li> </ol>"},{"location":"contrib/#opening-a-pr","title":"Opening a PR","text":"<p>Once you're ready to contribute your code change back, open a PR (remember to target the <code>dev</code> branch unless this is a hotfix), fill out the PR template, and then tag @OpenBagTwo for review.</p>"},{"location":"contrib/#license","title":"License","text":"<p>This project--the executable, source code and all documentation--are published under the GNU Public License v3, and any contributions to or derivatives of this project must be licensed under compatible terms.</p>"},{"location":"installation/","title":"Installation","text":"<p>Coming soon!</p>"},{"location":"suggestions/","title":"Best Practices and Suggested Workflows","text":"<p>Coming soon!</p>"},{"location":"usage/","title":"Using <code>gsb</code>","text":"<p>Coming soon!</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gsb<ul> <li>onboard</li> <li>history</li> <li>logging</li> <li>backup</li> <li>rewind</li> <li>manifest</li> </ul> </li> </ul>"},{"location":"reference/gsb/","title":"gsb","text":"<p>Top-level imports</p>"},{"location":"reference/gsb/backup/","title":"backup","text":"<p>Functionality for creating backups</p>"},{"location":"reference/gsb/backup/#gsb.backup.create_backup","title":"<code>create_backup(repo_root, tag=None)</code>","text":"<p>Create a new backup</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory containing the GSB-managed repo</p> required <code>tag</code> <code>str</code> <p>By default, this method just creates an \"untagged\" backup with a default commit message. To tag this backup, provide a description of the backup to use for both the commit message and the tag annotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An identifier for the backup in the form of either a commit hash or a tag name</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the specified repo does not exist or is not a gsb-managed repo</p> <code>ValueError</code> <p>If there are no changes to commit and no tag message was provided</p> Source code in <code>gsb/backup.py</code> <pre><code>def create_backup(repo_root: Path, tag: str | None = None) -&gt; str:\n\"\"\"Create a new backup\n    Parameters\n    ----------\n    repo_root : Path\n        The directory containing the GSB-managed repo\n    tag : str, optional\n        By default, this method just creates an \"untagged\" backup with a default\n        commit message. To tag this backup, provide a description of the backup\n        to use for both the commit message and the tag annotation.\n    Returns\n    -------\n    str\n        An identifier for the backup in the form of either a commit hash or a\n        tag name\n    Raises\n    ------\n    OSError\n        If the specified repo does not exist or is not a gsb-managed repo\n    ValueError\n        If there are no changes to commit and no tag message was provided\n    \"\"\"\nmanifest = Manifest.of(repo_root)\n_git.add(repo_root, manifest.patterns)\n_git.force_add(repo_root, REQUIRED_FILES)\ntry:\nidentifier = _git.commit(repo_root, tag or \"Manual backup\").hash\nlogging.info(\"Changes committed with hash %s\", identifier)\nexcept ValueError:\nif not tag:\nraise\nlogging.info(\"Nothing new to commit--all files are up-to-date.\")\nif tag:\nidentifier = _git.tag(repo_root, _generate_tag_name(), tag).name\nlogging.log(IMPORTANT, \"Created new tagged backup: %s\", identifier)\nreturn identifier\n</code></pre>"},{"location":"reference/gsb/history/","title":"history","text":"<p>Functionality for tracking and managing revision history</p>"},{"location":"reference/gsb/history/#gsb.history.get_history","title":"<code>get_history(repo_root, tagged_only=True, include_non_gsb=False, limit=-1, since=dt.datetime(1970, 1, 1))</code>","text":"<p>Retrieve a list of GSB-managed versions</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory containing the GSB-managed repo</p> required <code>tagged_only</code> <code>bool</code> <p>By default, this method only returns tagged backups. To include all available revisions, pass in <code>tagged_only=False</code>.</p> <code>True</code> <code>include_non_gsb</code> <code>bool</code> <p>By default, this method excludes any revisions created outside of <code>gsb</code>. To include all git commits and tags, pass in <code>include_non_gsb=True</code>.</p> <code>False</code> <code>limit</code> <code>int</code> <p>By default, this method returns the entire history. To return only the last n revisions, pass in <code>limit=n</code>.</p> <code>-1</code> <code>since</code> <code>date or timestamp</code> <p>By default, this method returns the entire history. To return only revisions made on or after a certain date, pass in <code>since=&lt;start_date&gt;</code>.</p> <code>dt.datetime(1970, 1, 1)</code> <p>Returns:</p> Type Description <code>list of dict</code> <p>metadata on the requested revisions, sorted in reverse-chronological order</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the specified repo does not exist or is not a git repo</p> Source code in <code>gsb/history.py</code> <pre><code>def get_history(\nrepo_root: Path,\ntagged_only: bool = True,\ninclude_non_gsb: bool = False,\nlimit: int = -1,\nsince: dt.date = dt.datetime(1970, 1, 1),\n) -&gt; list[_Revision]:\n\"\"\"Retrieve a list of GSB-managed versions\n    Parameters\n    ----------\n    repo_root : Path\n        The directory containing the GSB-managed repo\n    tagged_only : bool, optional\n        By default, this method only returns tagged backups. To include\n        all available revisions, pass in `tagged_only=False`.\n    include_non_gsb : bool, optional\n        By default, this method excludes any revisions created outside of `gsb`.\n        To include all git commits and tags, pass in `include_non_gsb=True`.\n    limit : int, optional\n        By default, this method returns the entire history. To return only the\n        last _n_ revisions, pass in `limit=n`.\n    since : date or timestamp, optional\n        By default, this method returns the entire history. To return only\n        revisions made on or after a certain date, pass in `since=&lt;start_date&gt;`.\n    Returns\n    -------\n    list of dict\n        metadata on the requested revisions, sorted in reverse-chronological\n        order\n    Raises\n    ------\n    OSError\n        If the specified repo does not exist or is not a git repo\n    \"\"\"\ntag_lookup = {\ntag.target: tag for tag in _git.get_tags(repo_root, annotated_only=True)\n}\nLOGGER.debug(\"Retrieved %s tags\", len(tag_lookup))\nrevisions: list[_Revision] = []\nfor commit in _git.log(repo_root):\nif len(revisions) == limit:\nbreak\nif commit.timestamp &lt; since:\nbreak\nif tag := tag_lookup.get(commit):\nidentifier = tag.name\nis_gsb = tag.gsb if tag.gsb is not None else commit.gsb\ndescription = tag.annotation or commit.message\nelse:\nif tagged_only:\ncontinue\nidentifier = commit.hash[:8]\nis_gsb = commit.gsb\ndescription = commit.message\nif not include_non_gsb and not is_gsb:\ncontinue\nLOGGER.log(\nIMPORTANT,\n\"%d. %s from %s\",\nlen(revisions) + 1,\ntag.name if tag else commit.hash[:8],\ncommit.timestamp.isoformat(\"-\"),\n)\nLOGGER.debug(\"Full reference: %s\", commit.hash)\nLOGGER.info(\"%s\", description)\nrevisions.append(\n{\n\"identifier\": identifier,\n\"description\": description.strip(),\n\"timestamp\": commit.timestamp,\n}\n)\nreturn revisions\n</code></pre>"},{"location":"reference/gsb/logging/","title":"logging","text":"<p>Common logging utilities</p>"},{"location":"reference/gsb/logging/#gsb.logging.CLIFormatter","title":"<code>CLIFormatter</code>","text":"<p>             Bases: <code>logging.Formatter</code></p> <p>Colorful formatter for the CLI</p> <p>h/t https://stackoverflow.com/a/56944256</p> Source code in <code>gsb/logging.py</code> <pre><code>class CLIFormatter(logging.Formatter):\n\"\"\"Colorful formatter for the CLI\n    h/t https://stackoverflow.com/a/56944256\n    \"\"\"\ngrey = \"\\x1b[2;20m\"\nyellow = \"\\x1b[33;20m\"\nbold_red = \"\\x1b[31;1m\"\nreset = \"\\x1b[0m\"\nFORMATS = {\nlogging.DEBUG: grey + \"%(message)s\" + reset,\nlogging.INFO: \"%(message)s\",\nIMPORTANT: \"%(message)s\",\nlogging.WARNING: yellow + \"%(message)s\" + reset,\nlogging.ERROR: bold_red + \"%(message)s\" + reset,\nlogging.CRITICAL: bold_red + \"%(message)s\" + reset,\n}\ndef format(self, record: logging.LogRecord) -&gt; str:\nreturn logging.Formatter(self.FORMATS.get(record.levelno)).format(record)\n</code></pre>"},{"location":"reference/gsb/logging/#gsb.logging.verbosity_to_log_level","title":"<code>verbosity_to_log_level(verbosity)</code>","text":"<p>Convert a verbosity level (number of <code>-v</code>s minus number of <code>-q</code>s) to a logging level</p> <p>Parameters:</p> Name Type Description Default <code>verbosity</code> <code>int</code> <p>A verbosity level usually specified by the number of <code>-v</code> flags a user provides minus the number of <code>-q</code> flags. As a baseline, a verbosity of 0 will set the level to handle all messages above (excluding) the INFO level.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The corresponding log level that should be set</p>"},{"location":"reference/gsb/logging/#gsb.logging.verbosity_to_log_level--notes","title":"Notes","text":"<p>Technically the default logging level is set just high enough to exclude DEBUG by default. This allows us to capture intermediate log levels (read: <code>IMPORTANT</code>) at the <code>verbosity = -1</code> (<code>-q</code>) level.</p> Source code in <code>gsb/logging.py</code> <pre><code>def verbosity_to_log_level(verbosity: int) -&gt; int:\n\"\"\"Convert a verbosity level (number of `-v`s minus number of `-q`s) to\n    a logging level\n    Parameters\n    ----------\n    verbosity: int\n        A verbosity level usually specified by the number of `-v` flags a user\n        provides minus the number of `-q` flags. As a baseline, a verbosity of\n        0 will set the level to handle all messages above (excluding) the\n        INFO level.\n    Returns\n    -------\n    int\n        The corresponding log level that should be set\n    Notes\n    -----\n    Technically the default logging level is set just high enough to exclude\n    DEBUG by default. This allows us to capture intermediate log levels (read:\n    `IMPORTANT`) at the `verbosity = -1` (`-q`) level.\n    \"\"\"\nreturn logging.INFO + 1 - 10 * verbosity\n</code></pre>"},{"location":"reference/gsb/manifest/","title":"manifest","text":"<p>Configuration definition for an individual GSB-managed save</p>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest","title":"<code>Manifest</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Save-specific configuration</p> <p>Attributes:</p> Name Type Description <code>root</code> <code>Path</code> <p>The directory containing the save / repo</p> <code>patterns</code> <code>tuple of str</code> <p>The glob match-patterns that determine which files get tracked</p> Source code in <code>gsb/manifest.py</code> <pre><code>class Manifest(NamedTuple):\n\"\"\"Save-specific configuration\n    Attributes\n    ----------\n    root : Path\n        The directory containing the save / repo\n    patterns : tuple of str\n        The glob match-patterns that determine which files get tracked\n    \"\"\"\nroot: Path\npatterns: tuple[str, ...]\n@classmethod\ndef of(cls, repo_root: Path) -&gt; Self:\n\"\"\"Read the manifest of the specified GSB repo\n        Parameters\n        ----------\n        repo_root : Path\n            The root directory of the gsb-managed repo\n        Returns\n        -------\n        Manifest\n            the parsed manifest\n        Raises\n        ------\n        ValueError\n            If the configuration cannot be parsed\n        OSError\n            If the file does not exist or cannot otherwise be read\n        \"\"\"\nLOGGER.debug(\"Loading %s from %s\", MANIFEST_NAME, repo_root)\nas_dict: dict[str, Any] = {\"root\": repo_root}\ncontents: _ManifestDict = tomllib.loads((repo_root / MANIFEST_NAME).read_text())\nfor key, value in contents.items():\nif key in Manifest._fields:\nif isinstance(value, list):\nvalue = tuple(value)\nas_dict[key] = value\nreturn cls(**as_dict)\ndef write(self) -&gt; None:\n\"\"\"Write the manifest to file, overwriting any existing configuration\n        Returns\n        -------\n        None\n        Notes\n        -----\n        The location and name of this file is controlled by the `root` attribute\n        and the `MANIFEST_NAME` constant, respectively, and cannot be overridden\n        Raises\n        ------\n        OSError\n            If the destination folder (`root`) does not exist or cannot be\n            written to\n        \"\"\"\nas_dict = {\n\"generated_by_gsb\": get_versions()[\"version\"],\n\"last_modified\": dt.datetime.now().isoformat(sep=\" \"),\n}\nfor attribute, value in self._asdict().items():  # pylint: disable=no-member\n#                  see: https://github.com/pylint-dev/pylint/issues/7891\nif attribute == \"root\":\ncontinue\nas_dict[attribute] = value\nas_toml = _to_toml(as_dict)\nLOGGER.debug(\"Writing %s to %s\", MANIFEST_NAME, self.root)\n(self.root / MANIFEST_NAME).write_text(as_toml)\n</code></pre>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest.of","title":"<code>of(repo_root)</code>  <code>classmethod</code>","text":"<p>Read the manifest of the specified GSB repo</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The root directory of the gsb-managed repo</p> required <p>Returns:</p> Type Description <code>Manifest</code> <p>the parsed manifest</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration cannot be parsed</p> <code>OSError</code> <p>If the file does not exist or cannot otherwise be read</p> Source code in <code>gsb/manifest.py</code> <pre><code>@classmethod\ndef of(cls, repo_root: Path) -&gt; Self:\n\"\"\"Read the manifest of the specified GSB repo\n    Parameters\n    ----------\n    repo_root : Path\n        The root directory of the gsb-managed repo\n    Returns\n    -------\n    Manifest\n        the parsed manifest\n    Raises\n    ------\n    ValueError\n        If the configuration cannot be parsed\n    OSError\n        If the file does not exist or cannot otherwise be read\n    \"\"\"\nLOGGER.debug(\"Loading %s from %s\", MANIFEST_NAME, repo_root)\nas_dict: dict[str, Any] = {\"root\": repo_root}\ncontents: _ManifestDict = tomllib.loads((repo_root / MANIFEST_NAME).read_text())\nfor key, value in contents.items():\nif key in Manifest._fields:\nif isinstance(value, list):\nvalue = tuple(value)\nas_dict[key] = value\nreturn cls(**as_dict)\n</code></pre>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest.write","title":"<code>write()</code>","text":"<p>Write the manifest to file, overwriting any existing configuration</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest.write--notes","title":"Notes","text":"<p>The location and name of this file is controlled by the <code>root</code> attribute and the <code>MANIFEST_NAME</code> constant, respectively, and cannot be overridden</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the destination folder (<code>root</code>) does not exist or cannot be written to</p> Source code in <code>gsb/manifest.py</code> <pre><code>def write(self) -&gt; None:\n\"\"\"Write the manifest to file, overwriting any existing configuration\n    Returns\n    -------\n    None\n    Notes\n    -----\n    The location and name of this file is controlled by the `root` attribute\n    and the `MANIFEST_NAME` constant, respectively, and cannot be overridden\n    Raises\n    ------\n    OSError\n        If the destination folder (`root`) does not exist or cannot be\n        written to\n    \"\"\"\nas_dict = {\n\"generated_by_gsb\": get_versions()[\"version\"],\n\"last_modified\": dt.datetime.now().isoformat(sep=\" \"),\n}\nfor attribute, value in self._asdict().items():  # pylint: disable=no-member\n#                  see: https://github.com/pylint-dev/pylint/issues/7891\nif attribute == \"root\":\ncontinue\nas_dict[attribute] = value\nas_toml = _to_toml(as_dict)\nLOGGER.debug(\"Writing %s to %s\", MANIFEST_NAME, self.root)\n(self.root / MANIFEST_NAME).write_text(as_toml)\n</code></pre>"},{"location":"reference/gsb/onboard/","title":"onboard","text":"<p>Functionality for onboarding a new save state</p>"},{"location":"reference/gsb/onboard/#gsb.onboard.create_repo","title":"<code>create_repo(repo_root, *patterns, ignore=None)</code>","text":"<p>Create a new <code>gsb</code>-managed git repo in the specified location</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory where the repo should be created</p> required <code>patterns</code> <code>str</code> <p>List of glob-patterns to match, specifying what in the working directory should be archived. If none are provided, then it will be assumed that the intent is to back up the entire folder and all its contents.</p> <code>()</code> <code>ignore</code> <code>list of str</code> <p>List of glob-patterns to ignore. If None are specified, then nothing will be ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>Manifest</code> <p>The static configuration for that repo</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If there is already a <code>gsb</code> repo in that location</p> <code>OSError</code> <p>If <code>repo_root</code> does not exist, is not a directory or cannot be accessed</p> Source code in <code>gsb/onboard.py</code> <pre><code>def create_repo(\nrepo_root: Path, *patterns: str, ignore: Iterable[str] | None = None\n) -&gt; Manifest:\n\"\"\"Create a new `gsb`-managed git repo in the specified location\n    Parameters\n    ----------\n    repo_root : Path\n        The directory where the repo should be created\n    patterns : str\n        List of glob-patterns to match, specifying what in the working directory\n        should be archived. If none are provided, then it will be assumed that\n        the intent is to back up the *entire* folder and all its contents.\n    ignore : list of str, optional\n        List of glob-patterns to *ignore*. If None are specified, then nothing\n        will be ignored.\n    Returns\n    -------\n    Manifest\n        The static configuration for that repo\n    Raises\n    ------\n    FileExistsError\n        If there is already a `gsb` repo in that location\n    OSError\n        If `repo_root` does not exist, is not a directory or cannot be accessed\n    \"\"\"\nif (repo_root / MANIFEST_NAME).exists():\nraise FileExistsError(f\"{repo_root} already contains a GSB-managed repo\")\nif not patterns:\npatterns = (\".\",)\nif \".\" not in patterns:\npatterns = tuple(set(patterns))\n_git.init(repo_root)\n_update_gitignore(repo_root, ignore or ())\n# enforce round-trip\nManifest(repo_root, tuple(patterns)).write()\nmanifest = Manifest.of(repo_root)\nbackup.create_backup(repo_root, \"Start of gsb tracking\")\nreturn manifest\n</code></pre>"},{"location":"reference/gsb/rewind/","title":"rewind","text":"<p>Functionality for restoring to an old backup</p>"},{"location":"reference/gsb/rewind/#gsb.rewind.restore_backup","title":"<code>restore_backup(repo_root, revision, keep_gsb_files=True)</code>","text":"<p>Rewind to a previous backup state and create a new backup</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory containing the GSB-managed repo</p> required <code>revision</code> <code>str</code> <p>The commit hash or tag name of the backup to restore</p> required <code>keep_gsb_files</code> <code>bool</code> <p>By default, <code>.gsb_manifest</code> and <code>.gitignore</code> will not be restored (that is, the latest versions will be kept). To override this behavior, pass in <code>keep_gsb_files = False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The tag name of the new restored backup</p>"},{"location":"reference/gsb/rewind/#gsb.rewind.restore_backup--notes","title":"Notes","text":"<p>Before creating the backup, any un-backed up changes will first be backed up</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the specified repo does not exist or is not a gsb-managed repo</p> <code>ValueError</code> <p>If the specified revision does not exist</p> Source code in <code>gsb/rewind.py</code> <pre><code>def restore_backup(repo_root: Path, revision: str, keep_gsb_files: bool = True) -&gt; str:\n\"\"\"Rewind to a previous backup state and create a new backup\n    Parameters\n    ----------\n    repo_root : Path\n        The directory containing the GSB-managed repo\n    revision : str\n        The commit hash or tag name of the backup to restore\n    keep_gsb_files : bool, optional\n        By default, `.gsb_manifest` and `.gitignore` *will not* be restored\n        (that is, the latest versions will be kept). To override this behavior,\n        pass in `keep_gsb_files = False`.\n    Returns\n    -------\n    str\n        The tag name of the new restored backup\n    Notes\n    -----\n    Before creating the backup, any un-backed up changes will first be backed up\n    Raises\n    ------\n    OSError\n        If the specified repo does not exist or is not a gsb-managed repo\n    ValueError\n        If the specified revision does not exist\n    \"\"\"\n_git.show(repo_root, revision)\nLOGGER.log(\nIMPORTANT, \"Backing up any unsaved changes before rewinding to %s\", revision\n)\norig_head = backup.create_backup(\nrepo_root, f\"Backing up state before rewinding to {revision}\"\n)\n_git.reset(repo_root, revision, hard=True)\n_git.reset(repo_root, orig_head, hard=False)\nif keep_gsb_files:\n_git.checkout_files(repo_root, orig_head, backup.REQUIRED_FILES)\nreturn backup.create_backup(repo_root, f\"Restored to {revision}\")\n</code></pre>"},{"location":"coverage/","title":"Coverage","text":""}]}