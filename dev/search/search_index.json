{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Game Save Backups","text":"<p>A tool for managing incremental backups of your save states using Git!</p>"},{"location":"#in-a-nutshell","title":"In a Nutshell","text":"<p>Does Steam keep corrupting your cloud saves?</p> <p>Does it take too long to create or restore a Minecraft backup?</p> <p>Do you want to rewind your game five hours and explore what might have been if only you'd punched that NPC in the face?</p> <p>If that sounds like you, then <code>gsb</code> is here to help! This is a lightweight wrapper around the Git version control system that's optimized for game saves. Features (will) include:</p> <ul> <li>automated incremental backups</li> <li>painless savegame restores</li> <li>easy history navigation</li> <li>revision history compression and cleaning</li> <li>support for branches</li> <li>workflows for implementing 3-2-1 backups</li> <li>full compatibility with Git and other git-based tools...</li> <li>... all without ever needing to know a thing about Git</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The <code>gsb</code> package is written for Python 3.11 but otherwise should run on any operating system and architecture.</p> <p>The latest release can be installed from PyPI via <code>pip</code>:</p> <pre><code>$ python -m pip install --user gsb\n</code></pre> <p>Full installation instructions can be found on GitHub Pages.</p>"},{"location":"#usage","title":"Usage","text":"<p>The recommended way to interact with <code>gsb</code> is via its  command-line interface. Once you've installed the package, run the following command to get an overview of the available actions:</p> <pre><code>$ gsb --help\n</code></pre> <p>and use:</p> <p><pre><code>$ gsb &lt;verb&gt; --help\n</code></pre> (e.g. <code>gsb backup --help</code>)</p> <p>for further details on running each of those commands.</p> <p>Full documentation, including tutorials, examples and full CLI docs, can be found on GitHub Pages.</p>"},{"location":"#quick-start-guide","title":"Quick-Start Guide","text":"<p>Coming soon!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you're interested in helping develop this project, have a look at the repo backlog and then read through the contributor's guide.</p>"},{"location":"#license","title":"License","text":"<p>This project--the executable, source code and all documentation--are published under the GNU Public License v3, and any contributions to or derivatives of this project must be licensed under compatible terms.</p>"},{"location":"about/","title":"About <code>gsb</code>","text":"<p>Coming soon!</p>"},{"location":"cli/","title":"Full Command-Line Interface Documentation","text":""},{"location":"cli/#gsb","title":"gsb","text":"<p>CLI for managing incremental backups of your save states using Git!</p> <p>Usage:</p> <pre><code>gsb [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  -h, --help         Show this message and exit.\n  -v, -V, --version  Show the version and exit.\n</code></pre>"},{"location":"cli/#backup","title":"backup","text":"<p>Create a new backup.</p> <p>Usage:</p> <pre><code>gsb backup [OPTIONS] [SAVE_PATH]\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet       Decrease the amount of information that's printed.\n  -v, --verbose     Increase the amount of information that's printed.\n  --path SAVE_PATH  Optionally specify the root directory containing your save\n                    data. If no path is given, the current working directory\n                    will be used.\n  -c, --combine     Combine this backup and the last backup, or use -cc to\n                    combine ALL backups since the last tagged backup.\n  --tag \"MESSAGE\"   Specify a description for this backup and \"tag\" it for\n                    future reference.\n  --help            Show this message and exit.\n</code></pre>"},{"location":"cli/#delete","title":"delete","text":"<p>Delete one or more backups.</p> <p>Usage:</p> <pre><code>gsb delete [OPTIONS] [REVISION]...\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet       Decrease the amount of information that's printed.\n  -v, --verbose     Increase the amount of information that's printed.\n  --path SAVE_PATH  Optionally specify the root directory containing your save\n                    data. If no path is given, the current working directory\n                    will be used.\n  --help            Show this message and exit.\n</code></pre>"},{"location":"cli/#history","title":"history","text":"<p>List the available backups, starting with the most recent.</p> <p>Usage:</p> <pre><code>gsb history [OPTIONS] [SAVE_PATH]\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet                     Decrease the amount of information that's\n                                  printed.\n  -v, --verbose                   Increase the amount of information that's\n                                  printed.\n  --path SAVE_PATH                Optionally specify the root directory\n                                  containing your save data. If no path is\n                                  given, the current working directory will be\n                                  used.\n  -n, --limit INTEGER             The maximum number of backups to return.\n  --since [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]\n                                  Only show backups created after the\n                                  specified date.\n  -a, --all                       Include non-tagged backups.\n  -g, --include_non_gsb           Include backups created directly with Git /\n                                  outside of gsb.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#init","title":"init","text":"<p>Start tracking a save.</p> <p>Usage:</p> <pre><code>gsb init [OPTIONS] [TRACK_PATTERN]...\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet       Decrease the amount of information that's printed.\n  -v, --verbose     Increase the amount of information that's printed.\n  --path SAVE_PATH  Optionally specify the root directory containing your save\n                    data. If no path is given, the current working directory\n                    will be used.\n  --track TEXT      Provide a glob pattern to track (note: arguments without\n                    any flag will also be treated as track patterns).\n  --ignore TEXT     Provide a glob pattern to ignore. Each ignore pattern must\n                    be prefaced with the \"--ignore\" flag.\n  --help            Show this message and exit.\n</code></pre>"},{"location":"cli/#rewind","title":"rewind","text":"<p>Restore a backup to the specified REVISION.</p> <p>Usage:</p> <pre><code>gsb rewind [OPTIONS] [REVISION]\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet             Decrease the amount of information that's printed.\n  -v, --verbose           Increase the amount of information that's printed.\n  --path SAVE_PATH        Optionally specify the root directory containing\n                          your save data. If no path is given, the current\n                          working directory will be used.\n  --include_gsb_settings  Also revert the GSB configuration files (including\n                          .gitignore)\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"contrib/","title":"Contribution Guide","text":"<p>The <code>gsb</code> package  is an open source project, and its source code is publicly available on GitHub.</p> <p>Please open a new issue to report a bug or to propose a new feature or enhancement.</p> <p>If you would like to contribute your own bugfixes or code enhancements, start by forking this repo, and cloning it into your local workspace.</p> <p>Note</p> <p>Note that all work should be done off of the <code>dev</code> branch</p>"},{"location":"contrib/#setting-up-a-development-environment","title":"Setting up a Development Environment","text":"<p>The development environment for this package is managed using conda. If you don't have one already, I highly recommend using a conda-forge-based distribution, such as mambaforge.</p> <p>Once you have conda installed and your fork cloned to your local workspace, navigate to that workspace and:</p> <ol> <li>Create the development environment via    <pre><code>mamba env create\n</code></pre>    (substitute <code>conda</code> if you so choose)</li> <li>Activate the development environment:    <pre><code>conda activate gsb\n</code></pre></li> <li>Install the package in editable mode:    <pre><code>python -m pip install --user -e .[test]\n</code></pre></li> <li>Set up pre-commit:    <pre><code>pre-commit install\n</code></pre></li> </ol> <p>Once that's done, start developing! Pre-commit is a fantastic tool that will take care of most style-guide enforcement for you, but details are below.</p>"},{"location":"contrib/#style-guide","title":"Style Guide","text":"<p>This package follows the standard Python style guides, most notably PEP8, targeting the Python 3.10 feature set. The one exception is that the line length maximum is set to 88, not 79. All non-trivial and \"public\" functions must have docstrings in the NumPy style.</p> <p>All code should be fully type-hinted, leveraging the latest changes introduced to the language. Favor use of <code>| None</code> \u2705 instead of <code>Optional</code> \u274c and built-in types (<code>list</code>, <code>tuple</code> \u2705) over their capitalized types (<code>from typing import List, Tuple</code> \u274c).</p> Type Hinting Pro Tip <p>A good practice to follow when using type hints is to make your return hints as specific and explicit as possible while making your parameter hints as broad as the function will allow. For example: <pre><code>from typing import Any, Collection\n\n\ndef stringify_dedupe_and_sort(sort_me: Collection[Any]) -&gt; list[str]:\n    \"\"\"Take a collection of stuff, turn them all into strings, remove\n    any duplicates, and then return the results sorted in alphabetical\n    (lexical?) order\n\n    Parameters\n    ----------\n    sort_me : list-like\n        The things you want to sort\n\n    Returns\n    -------\n    list of str\n        The stringified, deduped and sorted items\n\n    Notes\n    -----\n    @ me if you want to see this implemented via a one-line comprehension!\n    \"\"\"\n    return_me: list[str] = []\n    for value in sort_me:\n        stringified: str = str(value)\n        for i, existing_value in enumerate(return_me):\n            if existing_value &gt; stringified:\n                return_me.insert(i, stringified)\n                break\n            elif existing_value == stringified:\n                break\n            else:\n                pass\n        else:\n            return_me.append(stringified)\n\n    return return_me\n</code></pre> In the above, <code>sort_me</code> could be a list of strings, a set of <code>Path</code>s, or really any group of objects that you can iteratethrough and that has a defined length (and even that isn't even technically a requirement). Meanwhile on the output side, you're defining right off the bat that <code>return_me</code> is going to be a list and then enforcing that every member will be a string.</p> <p>There are a variety of other style conventions, especially around non-Python files, but they will be automatically enforced by pre-commit.</p>"},{"location":"contrib/#unit-testing","title":"Unit Testing","text":"<p>While unit tests are not globally required, any PR will require validation that the changes introduced are performing as intended (see below), and unit tests are a great way to provide that, especially given that <code>gsb</code> is meant to run across a wide variety of platforms. This package uses py.test as its test runner, and a wide variety of testing utililities and fixtures are available for you to leverage for help mocking out file systems.</p>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>In addition to internal (docstring) documentation, <code>gsb</code> includes HTML documentation hosted on GitHub Pages. This includes the static guides (that you are literally reading right now) as well as dynamically-generated HTML docs.</p> <p>The tool that performs this magic is called MkDocs and is included in the <code>gsb</code> development environment. One of MkDocs' killer] features is its ability to quickly render and serve the documentation locally. To do this, navigate your terminal to the repo root, activate your <code>gsb</code> environment and run the command:</p> <pre><code>mkdocs serve\n</code></pre> <p>and the terminal will soon contain a link (typically to http://127.0.0.1:8000/) where you can preview the documentation.</p> <p>When developing <code>gsb</code>, you should both check the compiled API docs based on your docstrings (and changes to the CLI) to ensure that everything is rendering as it should.</p>"},{"location":"contrib/#development-workflow","title":"Development Workflow","text":"<p>Development of <code>gsb</code> follows Gitflow, with all development done on feature-branches created off the <code>dev</code> branch.</p> <p>Once a significant number of changes have been merged into <code>dev</code> (usually the culmination of a milestone), a staging branch will be created off of <code>dev</code>, and a PR will be opened targeting merging changes from that branch into <code>release</code>. This process is typically accompanied by the creation of release candidate versions which are built and uploaded to PyPI for pre-release testing. During this phase, changes will be made directly to the staging branch to fix any bugs or regressions that come up during testing.</p> <p>Once it's time to cut a release,</p> <ol> <li>The staging PR will be merged into <code>release</code>.</li> <li> <p>A new release will    be created targeting the <code>release</code> branch and with a tag of the form    <code>v0.x.y</code>. The release notes should highlight the    significant changes in the new version, and the auto-generated release notes    should be modified to cover the period from the last full release    (as opposed to just the last release candidate).</p> <p>Tip</p> <p>Create draft release notes when cutting the first release candidate so that you can just copy them into the full release</p> </li> <li> <p>Cutting the new release will automatically push a new package build to    pypi and    update the docs.</p> </li> <li>Once the release is complete, the <code>dev</code> branch must be rebased on top of    <code>release</code>. This serves two goals:    - it applies any changes committed directly to the staging branch to <code>dev</code>    - it keeps the commit history linear (and makes it much easier to calculate)      the number of commits in <code>dev</code> since the last release.</li> </ol>"},{"location":"contrib/#opening-a-pr","title":"Opening a PR","text":"<p>Once you're ready to contribute your code change back, open a PR (remember to target the <code>dev</code> branch unless this is a hotfix), fill out the PR template, and then tag @OpenBagTwo for review.</p>"},{"location":"contrib/#license","title":"License","text":"<p>This project--the executable, source code and all documentation--are published under the GNU Public License v3, and any contributions to or derivatives of this project must be licensed under compatible terms.</p>"},{"location":"installation/","title":"Installation","text":"<p>The <code>gsb</code> package has minimal dependencies and should run on pretty much any computer or operating system. It does require Python 3.11 or greater portable distributions (read: no need for admin privileges) of which are available through miniconda and mambaforge.</p>"},{"location":"installation/#installing-gsb","title":"Installing <code>gsb</code>","text":""},{"location":"installation/#inside-a-conda-environment","title":"Inside a conda environment","text":"<p>Skip this sub-section if you're using the system Python.</p> <p>These instructions assume that you've already downloaded and installed mambaforge or another conda distribution and that mamba/conda is already registered to your system path.</p> <ol> <li> <p>Open a terminal (miniforge prompt on Windows) and create a new virtual environment via:    <pre><code>mamba create -n gsb \"python&gt;=3.10\" \"pip&gt;22\"\n</code></pre>    (substitute <code>conda</code> for <code>mamba</code> as needed, and skip this step and the next if     you're using the system Python)</p> </li> <li> <p>Activate your new environment:     <pre><code>conda activate gsb\n</code></pre></p> </li> </ol> <p>Then continue onto the next section.</p>"},{"location":"installation/#installation-via-pip","title":"Installation via pip","text":"<ol> <li> <p>Install <code>gsb</code> from PyPI using pip:     <pre><code>python3 -m pip install --user gsb[test]\n</code></pre></p> </li> <li> <p>Ensure that <code>gsb</code> is compatible with your system by running:     <pre><code>python3 -m pytest --pyargs gsb.test\n</code></pre>     If all tests pass, then you're good to go!</p> </li> </ol> <p>Tip</p> <p>If you'd like <code>gsb</code> to be available outside of your virtual environment, you can copy the executable to somewhere within your system path, e.g. for Linux, starting with the virtual environment deactivated: <pre><code>$ echo $PATH\n/home/openbagtwo/.mambaforge/condabin:/home/openbagtwo/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin\n$ conda activate gsb\n$ which gsb\n/home/openbagtwo/.mambaforge/envs/gsb/bin/gsb\n$ cp /home/openbagtwo/.mambaforge/envs/gsb/bin/gsb ~/.local/bin/\n</code></pre></p>"},{"location":"installation/#bleeding-edge","title":"Bleeding Edge","text":"<p>If you'd like to test out upcoming features or help with beta testing, you can install from the current development branch via:</p> <pre><code>python -m pip install --user git+https://github.com/OpenBagTwo/gsb.git@dev#egg=gsb[test]\n</code></pre> <p>Be warned that any code on this branch is considered highly experimental. Given that this is a tool for managing backups make sure that you are not using it on any data that isn't also being backed up in another way.</p>"},{"location":"suggestions/","title":"Best Practices and Suggested Workflows","text":"<p>Coming soon!</p>"},{"location":"usage/","title":"Using <code>gsb</code>","text":"<p>PSA</p> <p>These are instructions for the pre-MVP release of <code>gsb</code>. Explicitly: these instructions require you to explicitly navigate to or the specify the path of every save file you want to manage, every time you run any command. By v0.1 this should no longer be required.</p>"},{"location":"usage/#locating-your-save-data","title":"Locating Your Save Data","text":"<p>Before setting up <code>gsb</code> to manage your game saves, you'll first need to know where your save data is located. This will, of course, vary wildly based on platform and title, but many games have support pages that will tell you where to look, and many game launchers provide menu options to open your save folder in a file explorer.</p>"},{"location":"usage/#start-tracking-with-gsb-init","title":"Start tracking with <code>gsb init</code>","text":"<p>Once you've located a game you want to save, open a command-line and navigate to the folder containing your save and run the command <code>gsb init</code>. By default, all files in the folder will be tracked, so if you only want to track certain files or subfolders, specify that using the <code>--track</code> flag (or if you want to ignore nay files matching a certain pattern, use <code>--ignore</code>).</p> <p>Pro Tip</p> <p>While <code>gsb</code> does not currently support the ability to separately manage individual files located in the same folder, this feature is planned.. In the meantime, for games where each save is located within a subfolder (e.g. Minecraft worlds), if you want to manage your saves separately, run <code>gsb init</code> inside each world folder rather than in your \"saves\" folder.</p>"},{"location":"usage/#create-a-backup-with-gsb-backup","title":"Create a backup with <code>gsb backup</code>","text":"<p>When you ran <code>gsb init</code> it automatically created your first backup. When you're ready to create your next one, navigate back to the folder where your save is stored and run the <code>gsb backup</code> command to create another.</p> <p>Note that <code>gsb</code> has two kinds of backups:</p> <ol> <li>\"Untagged\" backups (created by default) are good for just \"checking in\" regular gameplay    where you might want to restore to the last state if, say, a creeper blows up your base.</li> <li>\"Tagged\" backups (created by supplying the <code>--tag</code> argument along with a message) are    meant to denote specific points you might want to return to later (right before an epic    boss fight or right before a story branch).</li> </ol> <p>Pro Tip</p> <p>You can overwrite a previous backup using the <code>--combine</code> / <code>-c</code> flag. And if when making a new tagged backup you want to delete all of the untagged backups you've made since the last time you used the <code>--tag</code> flag, you can use <code>-cc</code>, e.g. <pre><code>gsb backup -cc --tag \"A backup that's actually important\"\n</code></pre></p>"},{"location":"usage/#list-your-backups-using-gsb-history","title":"List your backups using <code>gsb history</code>","text":"<p>You can view your list of available backups at any time by navigating to your save's folder and running <code>gsb history</code>. By default, this will show the identifiers and dates of all tagged <code>gsb</code>-managed backups, so have a look at the various command-line options to customize both the list of what you see and the amount of information you get on each backup.</p>"},{"location":"usage/#restore-a-backup-with-gsb-rewind","title":"Restore a backup with <code>gsb rewind</code>","text":"<p>If you want to restore a backup, you can do so via <code>gsb rewind</code>.</p> Technical Details <p>In order to keep your backup history linear, technically what happens when you \"rewind\" your save state is that the files at that revision are restored and then played forward as a new commit. That way all of your changes since the point you rewound to are still in your history (future versions of <code>gsb</code> will let you clean this up later).</p> <p>If you don't provide a restore point, the command will prompt you to choose from a list of recent backups.</p>"},{"location":"usage/#deleting-a-backup-with-gsb-delete","title":"Deleting a backup with <code>gsb delete</code>","text":"<p>Use <code>gsb delete</code> to delete any backups you no longer need. Note that this command doesn't actually delete anything on its own (so you won't recover any disk space immediately). What it does instead is rewrites your history to exclude those restore points, thus marking them as \"loose.\" To permanently delete these backups, you will need to download and install a full Git client and run a \"garbage collect\" to prune these loose objects.</p> Pruning via the Git CLI <p>If you have the Git command-line utility installed, the command to run is: <pre><code>git gc --aggressive --prune=now\n</code></pre></p>"},{"location":"usage/#advanced-history-management-directly-with-git","title":"Advanced History Management directly with Git","text":"<p>Behind the curtain, <code>gsb</code> runs on Git meaning you can run any advanced commands you wish on a <code>gsb</code>-managed save repo directly via the <code>git</code> CLI or any general-purpose Git tool.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gsb<ul> <li>logging</li> <li>onboard</li> <li>fastforward</li> <li>rewind</li> <li>manifest</li> <li>backup</li> <li>history</li> </ul> </li> </ul>"},{"location":"reference/gsb/","title":"gsb","text":"<p>Top-level imports</p>"},{"location":"reference/gsb/backup/","title":"backup","text":"<p>Functionality for creating backups</p>"},{"location":"reference/gsb/backup/#gsb.backup.create_backup","title":"<code>create_backup(repo_root, tag_message=None, commit_message=None, parent=None, tag_name=None)</code>","text":"<p>Create a new backup</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory containing the GSB-managed repo</p> required <code>tag_message</code> <code>str</code> <p>By default, this method just creates an \"untagged\" backup with a default commit message. To tag this backup, provide a description of the backup to use for both the commit message and the tag annotation.</p> <code>None</code> <code>commit_message</code> <code>str</code> <p>By default, the commit message will match the <code>tag_message</code>, if one is provided. Provide a value to this argument to explicitly set the commit message. If neither a <code>tag</code> nor a <code>commit_message</code> is provided, the default value will be \"GSB-managed commit\"</p> <code>None</code> <code>parent</code> <code>str | None</code> <p>By default, this new backup will be created as an incremental commit off of the current head. To instead reset to a specific revision, pass in an ID for that revision to this argument.</p> <code>None</code> <code>tag_name</code> <code>str</code> <p>By default, tag names are automatically generated. Use this argument to provide a custom tag name. This option is ignored when not creating a tag.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An identifier for the backup in the form of either a commit hash or a tag name</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the specified repo does not exist or is not a gsb-managed repo</p> <code>ValueError</code> <p>If there are no changes to commit and no tag message was provided, or if the specified \"parent\" could not be resolved.</p> Source code in <code>gsb/backup.py</code> <pre><code>def create_backup(\n    repo_root: Path,\n    tag_message: str | None = None,\n    commit_message: str | None = None,\n    parent: str | None = None,\n    tag_name: str | None = None,\n) -&gt; str:\n    \"\"\"Create a new backup\n\n    Parameters\n    ----------\n    repo_root : Path\n        The directory containing the GSB-managed repo\n    tag_message : str, optional\n        By default, this method just creates an \"untagged\" backup with a default\n        commit message. To tag this backup, provide a description of the backup\n        to use for both the commit message and the tag annotation.\n    commit_message : str, optional\n        By default, the commit message will match the `tag_message`, if one\n        is provided. Provide a value to this argument to explicitly set the\n        commit message. If neither a `tag` nor a `commit_message` is provided,\n        the default value will be \"GSB-managed commit\"\n    parent: str, optional\n        By default, this new backup will be created as an incremental commit\n        off of the current head. To instead reset to a specific revision,\n        pass in an ID for that revision to this argument.\n    tag_name : str, optional\n        By default, tag names are automatically generated. Use this argument to\n        provide a custom tag name. This option is ignored when not creating\n        a tag.\n\n    Returns\n    -------\n    str\n        An identifier for the backup in the form of either a commit hash or a\n        tag name\n\n    Raises\n    ------\n    OSError\n        If the specified repo does not exist or is not a gsb-managed repo\n    ValueError\n        If there are no changes to commit and no tag message was provided, or\n        if the specified \"parent\" could not be resolved.\n    \"\"\"\n    manifest = Manifest.of(repo_root)\n\n    if parent is not None:\n        _git.reset(repo_root, parent, hard=False)\n\n    _git.add(repo_root, manifest.patterns)\n    _git.force_add(repo_root, REQUIRED_FILES)\n    try:\n        identifier = _git.commit(\n            repo_root, commit_message or tag_message or \"GSB-managed commit\"\n        ).hash\n        LOGGER.info(\"Changes committed with hash %s\", identifier[:8])\n        LOGGER.debug(\"Full hash: %s\", identifier)\n    except ValueError:\n        if not tag_message:\n            raise\n        LOGGER.info(\"Nothing new to commit--all files are up-to-date.\")\n    if tag_message:\n        identifier = _git.tag(\n            repo_root, tag_name or generate_tag_name(), tag_message\n        ).name\n        LOGGER.log(IMPORTANT, \"Created new tagged backup: %s\", identifier)\n    return identifier\n</code></pre>"},{"location":"reference/gsb/backup/#gsb.backup.generate_tag_name","title":"<code>generate_tag_name()</code>","text":"<p>Generate a new calver-ish tag name</p> <p>Returns:</p> Type Description <code>str</code> <p>A tag name that should hopefully be distinctly GSB and distinct from any tags a user would manually create</p>"},{"location":"reference/gsb/backup/#gsb.backup.generate_tag_name--notes","title":"Notes","text":"<p>When unit testing, this method will need to be monkeypatched to provide even greater granularity... unless you want to use <code>time.sleep(1)</code> between each tag :O</p> Source code in <code>gsb/backup.py</code> <pre><code>def generate_tag_name() -&gt; str:\n    \"\"\"Generate a new calver-ish tag name\n\n    Returns\n    -------\n    str\n        A tag name that should hopefully be distinctly GSB and distinct\n        from any tags a user would manually create\n\n    Notes\n    -----\n    When unit testing, this method will need to be monkeypatched to provide\n    even greater granularity... unless you want to use `time.sleep(1)` between\n    each tag :O\n    \"\"\"\n    return dt.datetime.now().strftime(\"gsb%Y.%m.%d+%H%M%S\")\n</code></pre>"},{"location":"reference/gsb/fastforward/","title":"fastforward","text":"<p>Functionality for removing backups from a repo's history</p>"},{"location":"reference/gsb/fastforward/#gsb.fastforward.delete_backups","title":"<code>delete_backups(repo_root, *revisions)</code>","text":"<p>Delete the specified backups</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory containing the GSB-managed repo</p> required <code>*revisions</code> <code>str</code> <p>The commit hashes and tag names of the backups to delete</p> <code>()</code> <p>Returns:</p> Type Description <code>str</code> <p>The tag name or commit hash for the most recent backup in the rewritten history</p>"},{"location":"reference/gsb/fastforward/#gsb.fastforward.delete_backups--notes","title":"Notes","text":"<ul> <li>The current repo state will always be kept (and, in the case that there   are un-backed-up changes, those changes will be backed up before the   history is rewritten).</li> <li>Deleting the initial backup is not currently supported.</li> </ul> <p>Raises:</p> Type Description <code>OSError</code> <p>If the specified repo does not exist or is not a gsb-managed repo</p> <code>ValueError</code> <p>If the specified revision does not exist</p> Source code in <code>gsb/fastforward.py</code> <pre><code>def delete_backups(repo_root: Path, *revisions: str) -&gt; str:\n    \"\"\"Delete the specified backups\n\n    Parameters\n    ----------\n    repo_root : Path\n        The directory containing the GSB-managed repo\n    *revisions : str\n        The commit hashes and tag names of the backups to delete\n\n    Returns\n    -------\n    str\n        The tag name or commit hash for the most recent backup in the rewritten\n        history\n\n    Notes\n    -----\n    - The current repo state will always be kept (and, in the case that there\n      are un-backed-up changes, those changes will be backed up before the\n      history is rewritten).\n    - Deleting the initial backup is not currently supported.\n\n    Raises\n    ------\n    OSError\n        If the specified repo does not exist or is not a gsb-managed repo\n    ValueError\n        If the specified revision does not exist\n    \"\"\"\n    to_delete: dict[_git.Commit, str] = {}\n    for revision in revisions:\n        match reference := _git.show(repo_root, revision):\n            case _git.Commit():\n                # keep the link back to the revision in case we need to raise\n                # an error about it later\n                to_delete[reference] = revision\n            case _git.Tag():\n                to_delete[reference.target] = revision\n            case _:  # pragma: no cover\n                raise NotImplementedError(f\"Don't know how to handle {type(reference)}\")\n\n    to_keep: list[str] = []\n    for commit in _git.log(repo_root):\n        if commit in to_delete.keys():\n            del to_delete[commit]\n        else:\n            to_keep.insert(0, commit.hash)\n            if len(to_delete) == 0:\n                break\n    else:\n        if len(to_delete) == 0:\n            raise NotImplementedError(\n                \"Deleting the initial backup is not currently supported.\"\n            )\n        else:\n            raise ValueError(\n                \"The following revisions exist, but they are not within\"\n                \" the linear commit history:\\n\"\n                + \"\\n\".join((f\"  - {revision}\" for revision in to_delete.values()))\n            )\n    return rewrite_history(repo_root, *to_keep)\n</code></pre>"},{"location":"reference/gsb/fastforward/#gsb.fastforward.rewrite_history","title":"<code>rewrite_history(repo_root, starting_point, *revisions)</code>","text":"<p>Rewrite the repo's history by only including the specified backups, effectively deleting the ones in between</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory containing the GSB-managed repo</p> required <code>starting_point</code> <code>str</code> <p>The commit hash or tag name to start revising from (all prior backups will be kept)</p> required <code>*revisions</code> <code>str</code> <p>The commit hashes / tag names for the backups that should be included / kept in the new history</p> <code>()</code> <p>Returns:</p> Type Description <code>str</code> <p>The tag name or commit hash for the most recent backup in the rewritten history</p>"},{"location":"reference/gsb/fastforward/#gsb.fastforward.rewrite_history--notes","title":"Notes","text":"<ul> <li>The current repo state will always be kept (and, in the case that there   are un-backed-up changes, those changes will be backed up before the   history is rewritten).</li> <li>The ordering of the provided revisions is not checked in advance, nor is   anything done to check for duplicates. Providing the backups out-of-order   will create a new history that frames the backups in the order provided.</li> </ul> <p>Raises:</p> Type Description <code>OSError</code> <p>If the specified repo does not exist or is not a gsb-managed repo</p> <code>ValueError</code> <p>If any of the specified revisions do not exist</p> Source code in <code>gsb/fastforward.py</code> <pre><code>def rewrite_history(repo_root: Path, starting_point: str, *revisions: str) -&gt; str:\n    \"\"\"Rewrite the repo's history by only including the specified backups,\n    effectively deleting the ones in between\n\n    Parameters\n    ----------\n    repo_root : Path\n        The directory containing the GSB-managed repo\n    starting_point: str\n        The commit hash or tag name to start revising from (all prior backups\n        will be kept)\n    *revisions: str\n        The commit hashes / tag names for the backups that should be included\n        / kept in the new history\n\n    Returns\n    -------\n    str\n        The tag name or commit hash for the most recent backup in the rewritten\n        history\n\n    Notes\n    -----\n    - The current repo state will always be kept (and, in the case that there\n      are un-backed-up changes, those changes will be backed up before the\n      history is rewritten).\n    - The ordering of the provided revisions is not checked in advance, nor is\n      anything done to check for duplicates. Providing the backups out-of-order\n      will create a new history that frames the backups in the order provided.\n\n    Raises\n    ------\n    OSError\n        If the specified repo does not exist or is not a gsb-managed repo\n    ValueError\n        If any of the specified revisions do not exist\n    \"\"\"\n    _ = _git.show(repo_root, starting_point)  # ensure starting point is valid\n    tag_lookup = {\n        tag.target: tag for tag in _git.get_tags(repo_root, annotated_only=False)\n    }\n    new_history: list[_git.Tag | _git.Commit] = []\n\n    for reference in revisions:\n        revision: _git.Tag | _git.Commit = _git.show(repo_root, reference)\n        if revision in tag_lookup.keys():\n            revision = tag_lookup[revision]  # type: ignore[index]\n        new_history.append(revision)\n\n    try:\n        head = backup.create_backup(repo_root)\n        LOGGER.log(IMPORTANT, \"Unsaved changes have been backed up as %s\", head[:8])\n        new_history.append(_git.show(repo_root, head))\n    except ValueError:\n        # nothing to back up\n        pass\n\n    try:\n        branch_name = dt.datetime.now().strftime(\"gsb_rebase_%Y.%m.%d+%H%M%S\")\n        _git.checkout_branch(repo_root, branch_name, starting_point)\n        head = starting_point\n        tags_to_update: list[tuple[_git.Tag, str]] = []\n        for revision in new_history:\n            match revision:\n                case _git.Commit():\n                    _git.reset(repo_root, revision.hash, hard=True)\n                    _git.reset(repo_root, head, hard=False)\n                    new_hash = _git.commit(\n                        repo_root,\n                        message=(\n                            revision.message + \"\\n\\n\" + f\"rebase of {revision.hash}\"\n                        ),\n                        timestamp=revision.timestamp,\n                    ).hash\n                    head = new_hash\n                case _git.Tag():\n                    _git.reset(repo_root, revision.target.hash, hard=True)\n                    _git.reset(repo_root, head, hard=False)\n                    new_hash = _git.commit(\n                        repo_root,\n                        message=(\n                            (revision.annotation or revision.name)\n                            + \"\\n\\n\"\n                            + f\"rebase of {revision.target.hash}\"\n                            + f' (\"{revision.target.message.strip()}\")'\n                        ),\n                        timestamp=revision.target.timestamp,\n                    ).hash\n                    tags_to_update.append((revision, new_hash))\n                    head = new_hash\n                case _:  # pragma: no cover\n                    raise NotImplementedError(\n                        f\"Don't know how to handle revision of type {type(revision)}\"\n                    )\n        for tag, target in tags_to_update:\n            _git.delete_tag(repo_root, tag.name)\n            _git.tag(repo_root, tag.name, tag.annotation, target=target)\n        try:\n            _git.delete_branch(repo_root, \"gsb\")\n        except ValueError as delete_fail:\n            # this can happen if you onboarded an existing repo to gsb, in\n            # which case the active branch won't necessarily be gsb\n            LOGGER.warning(\"Could not delete branch %s:\\n    %s\", \"gsb\", delete_fail)\n        _git.checkout_branch(repo_root, \"gsb\", head)\n        return head\n    except Exception as something_went_wrong:  # pragma: no cover\n        _git.reset(repo_root, head, hard=True)\n        raise something_went_wrong\n    finally:\n        _git.checkout_branch(repo_root, \"gsb\", None)\n        _git.delete_branch(repo_root, branch_name)\n</code></pre>"},{"location":"reference/gsb/history/","title":"history","text":"<p>Functionality for tracking and managing revision history</p>"},{"location":"reference/gsb/history/#gsb.history.Revision","title":"<code>Revision</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Metadata on a GSB-managed version</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>A short, unique identifier for the revision</p> required <code>commit_hash</code> <code>str</code> <p>The full hexadecimal hash associated with the revision</p> required <code>description</code> <code>str</code> <p>A description of the version</p> required <code>timestamp</code> <code>datetime</code> <p>The time at which the version was created</p> required <code>tagged</code> <code>bool</code> <p>Whether or not this is a tagged revision</p> required <code>gsb</code> <code>bool</code> <p>Whether or not this is a GSB-created revision</p> required Source code in <code>gsb/history.py</code> <pre><code>class Revision(TypedDict):\n    \"\"\"Metadata on a GSB-managed version\n\n    Parameters\n    ----------\n    identifier : str\n        A short, unique identifier for the revision\n    commit_hash : str\n        The full hexadecimal hash associated with the revision\n    description : str\n        A description of the version\n    timestamp : dt.datetime\n        The time at which the version was created\n    tagged : bool\n        Whether or not this is a tagged revision\n    gsb : bool\n        Whether or not this is a GSB-created revision\n    \"\"\"\n\n    identifier: str\n    commit_hash: str\n    description: str\n    timestamp: dt.datetime\n    tagged: bool\n    gsb: bool\n</code></pre>"},{"location":"reference/gsb/history/#gsb.history.get_history","title":"<code>get_history(repo_root, tagged_only=True, include_non_gsb=False, limit=-1, since=dt.datetime(1970, 1, 1), since_last_tagged_backup=False, always_include_latest=False)</code>","text":"<p>Retrieve a list of GSB-managed versions</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory containing the GSB-managed repo</p> required <code>tagged_only</code> <code>bool</code> <p>By default, this method only returns tagged backups. To include all available revisions, pass in <code>tagged_only=False</code>.</p> <code>True</code> <code>include_non_gsb</code> <code>bool</code> <p>By default, this method excludes any revisions created outside of <code>gsb</code>. To include all git commits and tags, pass in <code>include_non_gsb=True</code>.</p> <code>False</code> <code>limit</code> <code>int</code> <p>By default, this method returns the entire history. To return only the last n revisions, pass in <code>limit=n</code>.</p> <code>-1</code> <code>since</code> <code>date or timestamp</code> <p>By default, this method returns the entire history. To return only revisions made on or after a certain date, pass in <code>since=&lt;start_date&gt;</code>.</p> <code>datetime(1970, 1, 1)</code> <code>since_last_tagged_backup</code> <code>bool</code> <p>False by default. To return only revisions made since the last tagged backup, pass in <code>since_last_tagged_backup=True</code> (and, presumably, <code>tagged_only=False</code>). This flag is compatible with all other filters.</p> <code>False</code> <code>always_include_latest</code> <code>bool</code> <p>Whether to always include the latest backup, whether or not it's tagged or GSB-managed, and ignoring any other options. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list of dict</code> <p>metadata on the requested revisions, sorted in reverse-chronological order</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the specified repo does not exist or is not a git repo</p> <code>ValueError</code> <p>If called with <code>return_parent=True</code> <code>get_history</code> and the earliest commit had no parent (being the initial commit, itself).</p> Source code in <code>gsb/history.py</code> <pre><code>def get_history(\n    repo_root: Path,\n    tagged_only: bool = True,\n    include_non_gsb: bool = False,\n    limit: int = -1,\n    since: dt.date = dt.datetime(1970, 1, 1),\n    since_last_tagged_backup: bool = False,\n    always_include_latest: bool = False,\n) -&gt; list[Revision]:\n    \"\"\"Retrieve a list of GSB-managed versions\n\n    Parameters\n    ----------\n    repo_root : Path\n        The directory containing the GSB-managed repo\n    tagged_only : bool, optional\n        By default, this method only returns tagged backups. To include\n        all available revisions, pass in `tagged_only=False`.\n    include_non_gsb : bool, optional\n        By default, this method excludes any revisions created outside of `gsb`.\n        To include all git commits and tags, pass in `include_non_gsb=True`.\n    limit : int, optional\n        By default, this method returns the entire history. To return only the\n        last _n_ revisions, pass in `limit=n`.\n    since : date or timestamp, optional\n        By default, this method returns the entire history. To return only\n        revisions made on or after a certain date, pass in `since=&lt;start_date&gt;`.\n    since_last_tagged_backup: bool, optional\n        False by default. To return only revisions made since the last tagged\n        backup, pass in `since_last_tagged_backup=True` (and, presumably,\n        `tagged_only=False`). This flag is compatible with all other filters.\n    always_include_latest: bool, optional\n        Whether to always include the latest backup, whether or not it's\n        tagged or GSB-managed, and ignoring any other options. Default is False.\n\n    Returns\n    -------\n    list of dict\n        metadata on the requested revisions, sorted in reverse-chronological\n        order\n\n    Raises\n    ------\n    OSError\n        If the specified repo does not exist or is not a git repo\n    ValueError\n        If called with `return_parent=True` `get_history` and the earliest commit\n        had no parent (being the initial commit, itself).\n    \"\"\"\n    tag_lookup = {\n        tag.target: tag for tag in _git.get_tags(repo_root, annotated_only=True)\n    }\n    LOGGER.debug(\"Retrieved %s tags\", len(tag_lookup))\n\n    revisions: list[Revision] = []\n    defer_break = False\n    for commit in _git.log(repo_root):\n        if len(revisions) == limit or commit.timestamp &lt; since:\n            if always_include_latest:\n                defer_break = True\n            else:\n                break\n        if tag := tag_lookup.get(commit):\n            if since_last_tagged_backup:\n                break\n            tagged = True\n            identifier = tag.name\n            is_gsb = tag.gsb if tag.gsb is not None else commit.gsb\n            description = tag.annotation or commit.message\n        else:\n            if tagged_only and not always_include_latest:\n                continue\n            tagged = False\n            identifier = commit.hash[:8]\n            is_gsb = commit.gsb\n            description = commit.message\n        if not include_non_gsb and not is_gsb and not always_include_latest:\n            continue\n        revisions.append(\n            {\n                \"identifier\": identifier,\n                \"commit_hash\": commit.hash,\n                \"description\": description.strip(),\n                \"timestamp\": commit.timestamp,\n                \"tagged\": tagged,\n                \"gsb\": is_gsb,\n            }\n        )\n        if always_include_latest:\n            if defer_break:\n                break\n            always_include_latest = False\n    return revisions\n</code></pre>"},{"location":"reference/gsb/history/#gsb.history.log_revision","title":"<code>log_revision(revision, idx)</code>","text":"<p>Print (log) a revision</p> <p>Parameters:</p> Name Type Description Default <code>revision</code> <code>dict</code> <p>Metadata for the revision</p> required <code>idx</code> <code>int | None</code> <p>The index to give to the revision. If None is specified, the revision will be displayed with a \"-\" instead of a numbering.</p> required"},{"location":"reference/gsb/history/#gsb.history.log_revision--notes","title":"Notes","text":"<ul> <li>The version identifiers and dates are logged at the IMPORTANT (verbose=0) level</li> <li>The version descriptions are logged at the INFO (verbose=1) level</li> <li>The full version hashes are logged at the DEBUG (verbose=2) level</li> </ul> Source code in <code>gsb/history.py</code> <pre><code>def log_revision(revision: Revision, idx: int | None) -&gt; None:\n    \"\"\"Print (log) a revision\n\n    Parameters\n    ----------\n    revision : dict\n        Metadata for the revision\n    idx : int | None\n        The index to give to the revision. If None is specified, the revision\n        will be displayed with a \"-\" instead of a numbering.\n\n    Notes\n    -----\n    - The version identifiers and dates are logged at the IMPORTANT (verbose=0) level\n    - The version descriptions are logged at the INFO (verbose=1) level\n    - The full version hashes are logged at the DEBUG (verbose=2) level\n    \"\"\"\n    args: list[Any] = [revision[\"identifier\"], revision[\"timestamp\"].isoformat(\"-\")]\n    if idx is None:\n        format_string = \"- %s from %s\"\n    else:\n        format_string = \"%d. %s from %s\"\n        args.insert(0, idx)\n\n    LOGGER.log(IMPORTANT, format_string, *args)\n\n    LOGGER.debug(\"Full reference: %s\", revision[\"commit_hash\"])\n    LOGGER.info(\"%s\", revision[\"description\"])\n</code></pre>"},{"location":"reference/gsb/history/#gsb.history.show_history","title":"<code>show_history(repo_root, numbering=1, **kwargs)</code>","text":"<p>Fetch and print (log) the list of versions for the specified repo matching the given specs</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory containing the GSB-managed repo</p> required <code>numbering</code> <code>int | None</code> <p>When displaying the versions, the default behavior is to number the results, starting at 1. To set a different starting number, provide that. To use \"-\" instead of numbers, pass in <code>numbering=None</code>.</p> <code>1</code> <code>**kwargs</code> <p>Any other options will be passed directly to <code>get_history()</code> method</p> <code>{}</code>"},{"location":"reference/gsb/history/#gsb.history.show_history--notes","title":"Notes","text":"<p>See <code>log_revision()</code> for details about what information is logged to each log level</p> <p>Returns:</p> Type Description <code>list of dict</code> <p>metadata on the requested revisions, sorted in reverse-chronological order</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the specified repo does not exist or is not a git repo</p> Source code in <code>gsb/history.py</code> <pre><code>def show_history(\n    repo_root: Path,\n    numbering: int | None = 1,\n    **kwargs,\n) -&gt; list[Revision]:\n    \"\"\"Fetch and print (log) the list of versions for the specified repo matching\n    the given specs\n\n    Parameters\n    ----------\n    repo_root : Path\n        The directory containing the GSB-managed repo\n    numbering: int or None, optional\n        When displaying the versions, the default behavior is to number the\n        results, starting at 1. To set a different starting number, provide that.\n        To use \"-\" instead of numbers, pass in `numbering=None`.\n    **kwargs\n        Any other options will be passed directly to `get_history()`\n        method\n\n    Notes\n    -----\n    See `log_revision()` for details about what information is logged to each\n    log level\n\n    Returns\n    -------\n    list of dict\n        metadata on the requested revisions, sorted in reverse-chronological\n        order\n\n    Raises\n    ------\n    OSError\n        If the specified repo does not exist or is not a git repo\n    \"\"\"\n    history = get_history(repo_root, **kwargs)\n    for i, revision in enumerate(history):\n        log_revision(revision, i + numbering if numbering is not None else None)\n    return history\n</code></pre>"},{"location":"reference/gsb/logging/","title":"logging","text":"<p>Common logging utilities</p>"},{"location":"reference/gsb/logging/#gsb.logging.CLIFormatter","title":"<code>CLIFormatter</code>","text":"<p>             Bases: <code>Formatter</code></p> <p>Colorful formatter for the CLI</p> <p>h/t https://stackoverflow.com/a/56944256</p> Source code in <code>gsb/logging.py</code> <pre><code>class CLIFormatter(logging.Formatter):\n    \"\"\"Colorful formatter for the CLI\n\n    h/t https://stackoverflow.com/a/56944256\n    \"\"\"\n\n    grey = \"\\x1b[2;20m\"\n    yellow = \"\\x1b[33;20m\"\n    bold_red = \"\\x1b[31;1m\"\n    reset = \"\\x1b[0m\"\n\n    FORMATS = {\n        logging.DEBUG: grey + \"%(message)s\" + reset,\n        logging.INFO: \"%(message)s\",\n        IMPORTANT: \"%(message)s\",\n        logging.WARNING: yellow + \"%(message)s\" + reset,\n        logging.ERROR: bold_red + \"%(message)s\" + reset,\n        logging.CRITICAL: bold_red + \"%(message)s\" + reset,\n    }\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        return logging.Formatter(self.FORMATS.get(record.levelno)).format(record)\n</code></pre>"},{"location":"reference/gsb/logging/#gsb.logging.verbosity_to_log_level","title":"<code>verbosity_to_log_level(verbosity)</code>","text":"<p>Convert a verbosity level (number of <code>-v</code>s minus number of <code>-q</code>s) to a logging level</p> <p>Parameters:</p> Name Type Description Default <code>verbosity</code> <code>int</code> <p>A verbosity level usually specified by the number of <code>-v</code> flags a user provides minus the number of <code>-q</code> flags. As a baseline, a verbosity of 0 will set the level to handle all messages above (excluding) the INFO level.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The corresponding log level that should be set</p>"},{"location":"reference/gsb/logging/#gsb.logging.verbosity_to_log_level--notes","title":"Notes","text":"<p>Technically the default logging level is set just high enough to exclude DEBUG by default. This allows us to capture intermediate log levels (read: <code>IMPORTANT</code>) at the <code>verbosity = -1</code> (<code>-q</code>) level.</p> Source code in <code>gsb/logging.py</code> <pre><code>def verbosity_to_log_level(verbosity: int) -&gt; int:\n    \"\"\"Convert a verbosity level (number of `-v`s minus number of `-q`s) to\n    a logging level\n\n    Parameters\n    ----------\n    verbosity: int\n        A verbosity level usually specified by the number of `-v` flags a user\n        provides minus the number of `-q` flags. As a baseline, a verbosity of\n        0 will set the level to handle all messages above (excluding) the\n        INFO level.\n\n    Returns\n    -------\n    int\n        The corresponding log level that should be set\n\n    Notes\n    -----\n    Technically the default logging level is set just high enough to exclude\n    DEBUG by default. This allows us to capture intermediate log levels (read:\n    `IMPORTANT`) at the `verbosity = -1` (`-q`) level.\n    \"\"\"\n    return logging.INFO + 1 - 10 * verbosity\n</code></pre>"},{"location":"reference/gsb/manifest/","title":"manifest","text":"<p>Configuration definition for an individual GSB-managed save</p>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest","title":"<code>Manifest</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Save-specific configuration</p> <p>Attributes:</p> Name Type Description <code>root</code> <code>Path</code> <p>The directory containing the save / repo</p> <code>patterns</code> <code>tuple of str</code> <p>The glob match-patterns that determine which files get tracked</p> Source code in <code>gsb/manifest.py</code> <pre><code>class Manifest(NamedTuple):\n    \"\"\"Save-specific configuration\n\n    Attributes\n    ----------\n    root : Path\n        The directory containing the save / repo\n    patterns : tuple of str\n        The glob match-patterns that determine which files get tracked\n    \"\"\"\n\n    root: Path\n    patterns: tuple[str, ...]\n\n    @classmethod\n    def of(cls, repo_root: Path) -&gt; Self:\n        \"\"\"Read the manifest of the specified GSB repo\n\n        Parameters\n        ----------\n        repo_root : Path\n            The root directory of the gsb-managed repo\n\n        Returns\n        -------\n        Manifest\n            the parsed manifest\n\n        Raises\n        ------\n        ValueError\n            If the configuration cannot be parsed\n        OSError\n            If the file does not exist or cannot otherwise be read\n        \"\"\"\n        LOGGER.debug(\"Loading %s from %s\", MANIFEST_NAME, repo_root)\n        as_dict: dict[str, Any] = {\"root\": repo_root}\n        contents: _ManifestDict = tomllib.loads((repo_root / MANIFEST_NAME).read_text())\n        for key, value in contents.items():\n            if key in Manifest._fields:\n                if isinstance(value, list):\n                    value = tuple(value)\n                as_dict[key] = value\n        return cls(**as_dict)\n\n    def write(self) -&gt; None:\n        \"\"\"Write the manifest to file, overwriting any existing configuration\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        The location and name of this file is controlled by the `root` attribute\n        and the `MANIFEST_NAME` constant, respectively, and cannot be overridden\n\n        Raises\n        ------\n        OSError\n            If the destination folder (`root`) does not exist or cannot be\n            written to\n        \"\"\"\n        as_dict = {\n            \"generated_by_gsb\": get_versions()[\"version\"],\n            \"last_modified\": dt.datetime.now().isoformat(sep=\" \"),\n        }\n        for attribute, value in self._asdict().items():  # pylint: disable=no-member\n            #                  see: https://github.com/pylint-dev/pylint/issues/7891\n            if attribute == \"root\":\n                continue\n            as_dict[attribute] = value\n\n        as_toml = _to_toml(as_dict)\n\n        LOGGER.debug(\"Writing %s to %s\", MANIFEST_NAME, self.root)\n        (self.root / MANIFEST_NAME).write_text(as_toml)\n</code></pre>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest.of","title":"<code>of(repo_root)</code>  <code>classmethod</code>","text":"<p>Read the manifest of the specified GSB repo</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The root directory of the gsb-managed repo</p> required <p>Returns:</p> Type Description <code>Manifest</code> <p>the parsed manifest</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration cannot be parsed</p> <code>OSError</code> <p>If the file does not exist or cannot otherwise be read</p> Source code in <code>gsb/manifest.py</code> <pre><code>@classmethod\ndef of(cls, repo_root: Path) -&gt; Self:\n    \"\"\"Read the manifest of the specified GSB repo\n\n    Parameters\n    ----------\n    repo_root : Path\n        The root directory of the gsb-managed repo\n\n    Returns\n    -------\n    Manifest\n        the parsed manifest\n\n    Raises\n    ------\n    ValueError\n        If the configuration cannot be parsed\n    OSError\n        If the file does not exist or cannot otherwise be read\n    \"\"\"\n    LOGGER.debug(\"Loading %s from %s\", MANIFEST_NAME, repo_root)\n    as_dict: dict[str, Any] = {\"root\": repo_root}\n    contents: _ManifestDict = tomllib.loads((repo_root / MANIFEST_NAME).read_text())\n    for key, value in contents.items():\n        if key in Manifest._fields:\n            if isinstance(value, list):\n                value = tuple(value)\n            as_dict[key] = value\n    return cls(**as_dict)\n</code></pre>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest.write","title":"<code>write()</code>","text":"<p>Write the manifest to file, overwriting any existing configuration</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest.write--notes","title":"Notes","text":"<p>The location and name of this file is controlled by the <code>root</code> attribute and the <code>MANIFEST_NAME</code> constant, respectively, and cannot be overridden</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the destination folder (<code>root</code>) does not exist or cannot be written to</p> Source code in <code>gsb/manifest.py</code> <pre><code>def write(self) -&gt; None:\n    \"\"\"Write the manifest to file, overwriting any existing configuration\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    The location and name of this file is controlled by the `root` attribute\n    and the `MANIFEST_NAME` constant, respectively, and cannot be overridden\n\n    Raises\n    ------\n    OSError\n        If the destination folder (`root`) does not exist or cannot be\n        written to\n    \"\"\"\n    as_dict = {\n        \"generated_by_gsb\": get_versions()[\"version\"],\n        \"last_modified\": dt.datetime.now().isoformat(sep=\" \"),\n    }\n    for attribute, value in self._asdict().items():  # pylint: disable=no-member\n        #                  see: https://github.com/pylint-dev/pylint/issues/7891\n        if attribute == \"root\":\n            continue\n        as_dict[attribute] = value\n\n    as_toml = _to_toml(as_dict)\n\n    LOGGER.debug(\"Writing %s to %s\", MANIFEST_NAME, self.root)\n    (self.root / MANIFEST_NAME).write_text(as_toml)\n</code></pre>"},{"location":"reference/gsb/onboard/","title":"onboard","text":"<p>Functionality for onboarding a new save state</p>"},{"location":"reference/gsb/onboard/#gsb.onboard.create_repo","title":"<code>create_repo(repo_root, *patterns, ignore=None)</code>","text":"<p>Create a new <code>gsb</code>-managed git repo in the specified location</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory where the repo should be created</p> required <code>patterns</code> <code>str</code> <p>List of glob-patterns to match, specifying what in the working directory should be archived. If none are provided, then it will be assumed that the intent is to back up the entire folder and all its contents.</p> <code>()</code> <code>ignore</code> <code>list of str</code> <p>List of glob-patterns to ignore. If None are specified, then nothing will be ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>Manifest</code> <p>The static configuration for that repo</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If there is already a <code>gsb</code> repo in that location</p> <code>OSError</code> <p>If <code>repo_root</code> does not exist, is not a directory or cannot be accessed</p> Source code in <code>gsb/onboard.py</code> <pre><code>def create_repo(\n    repo_root: Path, *patterns: str, ignore: Iterable[str] | None = None\n) -&gt; Manifest:\n    \"\"\"Create a new `gsb`-managed git repo in the specified location\n\n    Parameters\n    ----------\n    repo_root : Path\n        The directory where the repo should be created\n    patterns : str\n        List of glob-patterns to match, specifying what in the working directory\n        should be archived. If none are provided, then it will be assumed that\n        the intent is to back up the *entire* folder and all its contents.\n    ignore : list of str, optional\n        List of glob-patterns to *ignore*. If None are specified, then nothing\n        will be ignored.\n\n    Returns\n    -------\n    Manifest\n        The static configuration for that repo\n\n    Raises\n    ------\n    FileExistsError\n        If there is already a `gsb` repo in that location\n    OSError\n        If `repo_root` does not exist, is not a directory or cannot be accessed\n    \"\"\"\n    if (repo_root / MANIFEST_NAME).exists():\n        raise FileExistsError(f\"{repo_root} already contains a GSB-managed repo\")\n    if not patterns:\n        patterns = (\".\",)\n    if \".\" not in patterns:\n        patterns = tuple(set(patterns))\n\n    _git.init(repo_root)\n\n    _update_gitignore(repo_root, ignore or ())\n\n    # enforce round-trip\n    Manifest(repo_root, tuple(patterns)).write()\n    manifest = Manifest.of(repo_root)\n\n    backup.create_backup(repo_root, \"Start of gsb tracking\")\n\n    return manifest\n</code></pre>"},{"location":"reference/gsb/rewind/","title":"rewind","text":"<p>Functionality for restoring to an old backup</p>"},{"location":"reference/gsb/rewind/#gsb.rewind.generate_restore_tag_name","title":"<code>generate_restore_tag_name(revision)</code>","text":"<p>Generate a new calver-ish tag name</p> <p>Parameters:</p> Name Type Description Default <code>revision</code> <code>str</code> <p>The commit hash or tag name of the backup to restore</p> required <p>Returns:</p> Type Description <code>str</code> <p>A tag name that indicates both the time a backup was restored and the identifier of the original revision</p> Source code in <code>gsb/rewind.py</code> <pre><code>def generate_restore_tag_name(revision: str) -&gt; str:\n    \"\"\"Generate a new calver-ish tag name\n\n    Parameters\n    ----------\n    revision : str\n        The commit hash or tag name of the backup to restore\n\n    Returns\n    -------\n    str\n        A tag name that indicates both the time a backup was restored and the\n        identifier of the original revision\n    \"\"\"\n    return f\"{backup.generate_tag_name()}.restore_of_{revision}\"\n</code></pre>"},{"location":"reference/gsb/rewind/#gsb.rewind.restore_backup","title":"<code>restore_backup(repo_root, revision, keep_gsb_files=True)</code>","text":"<p>Rewind to a previous backup state and create a new backup</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory containing the GSB-managed repo</p> required <code>revision</code> <code>str</code> <p>The commit hash or tag name of the backup to restore</p> required <code>keep_gsb_files</code> <code>bool</code> <p>By default, <code>.gsb_manifest</code> and <code>.gitignore</code> will not be restored (that is, the latest versions will be kept). To override this behavior, pass in <code>keep_gsb_files = False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The tag name of the new restored backup</p>"},{"location":"reference/gsb/rewind/#gsb.rewind.restore_backup--notes","title":"Notes","text":"<p>Before creating the backup, any un-backed up changes will first be backed up</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the specified repo does not exist or is not a gsb-managed repo</p> <code>ValueError</code> <p>If the specified revision does not exist</p> Source code in <code>gsb/rewind.py</code> <pre><code>def restore_backup(repo_root: Path, revision: str, keep_gsb_files: bool = True) -&gt; str:\n    \"\"\"Rewind to a previous backup state and create a new backup\n\n    Parameters\n    ----------\n    repo_root : Path\n        The directory containing the GSB-managed repo\n    revision : str\n        The commit hash or tag name of the backup to restore\n    keep_gsb_files : bool, optional\n        By default, `.gsb_manifest` and `.gitignore` *will not* be restored\n        (that is, the latest versions will be kept). To override this behavior,\n        pass in `keep_gsb_files = False`.\n\n    Returns\n    -------\n    str\n        The tag name of the new restored backup\n\n    Notes\n    -----\n    Before creating the backup, any un-backed up changes will first be backed up\n\n    Raises\n    ------\n    OSError\n        If the specified repo does not exist or is not a gsb-managed repo\n    ValueError\n        If the specified revision does not exist\n    \"\"\"\n    _git.show(repo_root, revision)\n\n    LOGGER.log(\n        IMPORTANT, \"Backing up any unsaved changes before rewinding to %s\", revision\n    )\n    orig_head = backup.create_backup(\n        repo_root, f\"Backing up state before rewinding to {revision}\"\n    )\n\n    _git.reset(repo_root, revision, hard=True)\n    _git.reset(repo_root, orig_head, hard=False)\n    if keep_gsb_files:\n        _git.checkout_files(repo_root, orig_head, backup.REQUIRED_FILES)\n    return backup.create_backup(\n        repo_root,\n        f\"Restored to {revision}\",\n        tag_name=generate_restore_tag_name(revision),\n    )\n</code></pre>"},{"location":"coverage/","title":"Coverage","text":""}]}