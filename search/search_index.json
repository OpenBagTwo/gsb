{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Game Save Backups","text":"<p>A tool for managing incremental backups of your save states using Git!</p>"},{"location":"#in-a-nutshell","title":"In a Nutshell","text":"<p>Does Steam keep corrupting your cloud saves?</p> <p>Does it take too long to create or restore a Minecraft backup?</p> <p>Do you want to rewind your game five hours and explore what might have been if only you'd punched that NPC in the face?</p> <p>If that sounds like you, then <code>gsb</code> is here to help! This is a lightweight wrapper around the Git version control system that's optimized for game saves. Features (will) include:</p> <ul> <li>automated incremental backups</li> <li>painless savegame restores</li> <li>easy history navigation</li> <li>revision history compression and cleaning</li> <li>support for branches</li> <li>workflows for implementing 3-2-1 backups</li> <li>full compatibility with Git and other git-based tools...</li> <li>... all without ever needing to know a thing about Git</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The <code>gsb</code> package is written for Python 3.11 but otherwise should run on any operating system and architecture.</p> <p>The latest release can be installed from PyPI via <code>pip</code>:</p> <pre><code>$ python -m pip install --user gsb\n</code></pre> <p>Full installation instructions can be found on GitHub Pages.</p>"},{"location":"#usage","title":"Usage","text":"<p>The recommended way to interact with <code>gsb</code> is via its  command-line interface. Once you've installed the package, run the following command to get an overview of the available actions:</p> <pre><code>$ gsb --help\n</code></pre> <p>and use:</p> <p><pre><code>$ gsb &lt;verb&gt; --help\n</code></pre> (e.g. <code>gsb backup --help</code>)</p> <p>for further details on running each of those commands.</p> <p>Full documentation, including tutorials, examples and full CLI docs, can be found on GitHub Pages.</p>"},{"location":"#quick-start-guide","title":"Quick-Start Guide","text":"<p>Coming soon!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you're interested in helping develop this project, have a look at the repo backlog and then read through the contributor's guide.</p>"},{"location":"#license","title":"License","text":"<p>This project--the executable, source code and all documentation--are published under the GNU Public License v3, and any contributions to or derivatives of this project must be licensed under compatible terms.</p>"},{"location":"about/","title":"About <code>gsb</code>","text":"<p>Coming soon!</p>"},{"location":"contrib/","title":"Contribution Guide","text":"<p>The <code>gsb</code> package  is an open source project, and its source code is publicly available on GitHub.</p> <p>Please open a new issue to report a bug or to propose a new feature or enhancement.</p> <p>If you would like to contribute your own bugfixes or code enhancements, start by forking this repo, and cloning it into your local workspace.</p> <p>Note</p> <p>Note that all work should be done off of the <code>dev</code> branch</p>"},{"location":"contrib/#setting-up-a-development-environment","title":"Setting up a Development Environment","text":"<p>The development environment for this package is managed using conda. If you don't have one already, I highly recommend using a conda-forge-based distribution, such as mambaforge.</p> <p>Once you have conda installed and your fork cloned to your local workspace, navigate to that workspace and:</p> <ol> <li>Create the development environment via    <pre><code>mamba env create\n</code></pre>    (substitute <code>conda</code> if you so choose)</li> <li>Activate the development environment:    <pre><code>conda activate gsb\n</code></pre></li> <li>Install the package in editable mode:    <pre><code>python -m pip install --user -e .[test]\n</code></pre></li> <li>Set up pre-commit:    <pre><code>pre-commit install\n</code></pre></li> </ol> <p>Once that's done, start developing! Pre-commit is a fantastic tool that will take care of most style-guide enforcement for you, but details are below.</p>"},{"location":"contrib/#style-guide","title":"Style Guide","text":"<p>This package follows the standard Python style guides, most notably PEP8, targeting the Python 3.10 feature set. The one exception is that the line length maximum is set to 88, not 79. All non-trivial and \"public\" functions must have docstrings in the NumPy style.</p> <p>All code should be fully type-hinted, leveraging the latest changes introduced to the language. Favor use of <code>| None</code> \u2705 instead of <code>Optional</code> \u274c and built-in types (<code>list</code>, <code>tuple</code> \u2705) over their capitalized types (<code>from typing import List, Tuple</code> \u274c).</p> Type Hinting Pro Tip <p>A good practice to follow when using type hints is to make your return hints as specific and explicit as possible while making your parameter hints as broad as the function will allow. For example: <pre><code>from typing import Any, Collection\ndef stringify_dedupe_and_sort(sort_me: Collection[Any]) -&gt; list[str]:\n\"\"\"Take a collection of stuff, turn them all into strings, remove\n    any duplicates, and then return the results sorted in alphabetical\n    (lexical?) order\n    Parameters\n    ----------\n    sort_me : list-like\n        The things you want to sort\n    Returns\n    -------\n    list of str\n        The stringified, deduped and sorted items\n    Notes\n    -----\n    @ me if you want to see this implemented via a one-line comprehension!\n    \"\"\"\nreturn_me: list[str] = []\nfor value in sort_me:\nstringified: str = str(value)\nfor i, existing_value in enumerate(return_me):\nif existing_value &gt; stringified:\nreturn_me.insert(i, stringified)\nbreak\nelif existing_value == stringified:\nbreak\nelse:\npass\nelse:\nreturn_me.append(stringified)\nreturn return_me\n</code></pre> In the above, <code>sort_me</code> could be a list of strings, a set of <code>Path</code>s, or really any group of objects that you can iteratethrough and that has a defined length (and even that isn't even technically a requirement). Meanwhile on the output side, you're defining right off the bat that <code>return_me</code> is going to be a list and then enforcing that every member will be a string.</p> <p>There are a variety of other style conventions, especially around non-Python files, but they will be automatically enforced by pre-commit.</p>"},{"location":"contrib/#unit-testing","title":"Unit Testing","text":"<p>While unit tests are not globally required, any PR will require validation that the changes introduced are performing as intended (see below), and unit tests are a great way to provide that, especially given that <code>gsb</code> is meant to run across a wide variety of platforms. This package uses py.test as its test runner, and a wide variety of testing utililities and fixtures are available for you to leverage for help mocking out file systems.</p>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>In addition to internal (docstring) documentation, <code>gsb</code> includes HTML documentation hosted on GitHub Pages. This includes the static guides (that you are literally reading right now) as well as dynamically-generated HTML docs.</p> <p>The tool that performs this magic is called MkDocs and is included in the <code>gsb</code> development environment. One of MkDocs' killer] features is its ability to quickly render and serve the documentation locally. To do this, navigate your terminal to the repo root, activate your <code>gsb</code> environment and run the command:</p> <pre><code>mkdocs serve\n</code></pre> <p>and the terminal will soon contain a link (typically to http://127.0.0.1:8000/) where you can preview the documentation.</p> <p>When developing <code>gsb</code>, you should both check the compiled API docs based on your docstrings (and changes to the CLI) to ensure that everything is rendering as it should.</p>"},{"location":"contrib/#development-workflow","title":"Development Workflow","text":"<p>Development of <code>gsb</code> follows Gitflow, with all development done on feature-branches created off the <code>dev</code> branch.</p> <p>Once a significant number of changes have been merged into <code>dev</code> (usually the culmination of a milestone), a staging branch will be created off of <code>dev</code>, and a PR will be opened targeting merging changes from that branch into <code>release</code>. This process is typically accompanied by the creation of release candidate versions which are built and uploaded to PyPI for pre-release testing. During this phase, changes will be made directly to the staging branch to fix any bugs or regressions that come up during testing.</p> <p>Once it's time to cut a release,</p> <ol> <li>The staging PR will be merged into <code>release</code>.</li> <li> <p>A new release will    be created targeting the <code>release</code> branch and with a tag of the form    <code>v0.x.y</code>. The release notes should highlight the    significant changes in the new version, and the auto-generated release notes    should be modified to cover the period from the last full release    (as opposed to just the last release candidate).</p> <p>Tip</p> <p>Create draft release notes when cutting the first release candidate so that you can just copy them into the full release</p> </li> <li> <p>Cutting the new release will automatically push a new package build to    pypi and    update the docs.</p> </li> <li>Once the release is complete, the <code>dev</code> branch must be rebased on top of    <code>release</code>. This serves two goals:    - it applies any changes committed directly to the staging branch to <code>dev</code>    - it keeps the commit history linear (and makes it much easier to calculate)      the number of commits in <code>dev</code> since the last release.</li> </ol>"},{"location":"contrib/#opening-a-pr","title":"Opening a PR","text":"<p>Once you're ready to contribute your code change back, open a PR (remember to target the <code>dev</code> branch unless this is a hotfix), fill out the PR template, and then tag @OpenBagTwo for review.</p>"},{"location":"contrib/#license","title":"License","text":"<p>This project--the executable, source code and all documentation--are published under the GNU Public License v3, and any contributions to or derivatives of this project must be licensed under compatible terms.</p>"},{"location":"installation/","title":"Installation","text":"<p>Coming soon!</p>"},{"location":"suggestions/","title":"Best Practices and Suggested Workflows","text":"<p>Coming soon!</p>"},{"location":"usage/","title":"Using <code>gsb</code>","text":"<p>Coming soon!</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gsb<ul> <li>cli</li> <li>history</li> <li>onboard</li> <li>manifest</li> </ul> </li> </ul>"},{"location":"reference/gsb/","title":"gsb","text":"<p>Top-level imports</p>"},{"location":"reference/gsb/cli/","title":"cli","text":""},{"location":"reference/gsb/cli/#gsb.cli.generate_parsers","title":"<code>generate_parsers()</code>","text":"<p>Generate the command-line parsers</p> <p>Returns:</p> Name Type Description <code>gsb_parser</code> <code>ArgumentParser</code> <p>The top-level argument parser responsible for routing arguments to specific action parsers</p> <code>action_parsers</code> <code>dict of str to ArgumentParser</code> <p>The verb-specific argument parsers</p> Source code in <code>gsb/cli.py</code> <pre><code>def generate_parsers() -&gt; tuple[ArgumentParser, dict[str, ArgumentParser]]:\n\"\"\"Generate the command-line parsers\n    Returns\n    -------\n    gsb_parser : ArgumentParser\n        The top-level argument parser responsible for routing arguments to\n        specific action parsers\n    action_parsers : dict of str to ArgumentParser\n        The verb-specific argument parsers\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/gsb/history/","title":"history","text":"<p>Functionality for tracking and managing revision history</p>"},{"location":"reference/gsb/history/#gsb.history.Revision","title":"<code>Revision</code>","text":"<p>         Bases: <code>TypedDict</code></p> <p>Metadata on a GSB-managed version</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>A unique identifier for the revision</p> required <code>description</code> <code>str</code> <p>A description of the version</p> required <code>timestamp</code> <code>dt.datetime</code> <p>The time at which the version was created</p> required Source code in <code>gsb/history.py</code> <pre><code>class Revision(TypedDict):\n\"\"\"Metadata on a GSB-managed version\n    Parameters\n    ----------\n    identifier : str\n        A unique identifier for the revision\n    description : str\n        A description of the version\n    timestamp : dt.datetime\n        The time at which the version was created\n    \"\"\"\nidentifier: str\ndescription: str\ntimestamp: dt.datetime\n</code></pre>"},{"location":"reference/gsb/history/#gsb.history.get_history","title":"<code>get_history(repo_root, tagged_only=True, include_non_gsb=False, limit=-1, since=dt.datetime(1970, 1, 1))</code>","text":"<p>Retrieve a list of GSB-managed versions</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory where the repo should be created</p> required <code>tagged_only</code> <code>bool</code> <p>By default, this method only returns tagged backups. To include all available revisions, pass in <code>tagged_only=False</code>.</p> <code>True</code> <code>include_non_gsb</code> <code>bool</code> <p>By default, this method excludes any revisions created outside of <code>gsb</code>. To include all git commits and tags, pass in <code>include_non_gsb=True</code>.</p> <code>False</code> <code>limit</code> <code>int</code> <p>By default, this method returns the entire history. To return only the last n revisions, pass in <code>limit=n</code>.</p> <code>-1</code> <code>since</code> <code>date or timestamp</code> <p>By default, this method returns the entire history. To return only revisions made on or after a certain date, pass in <code>since=&lt;start_date&gt;</code>.</p> <code>dt.datetime(1970, 1, 1)</code> <p>Returns:</p> Type Description <code>list of dict</code> <p>Metadata on the requested revisions, sorted in reverse-chronological order</p> Source code in <code>gsb/history.py</code> <pre><code>def get_history(\nrepo_root: Path,\ntagged_only: bool = True,\ninclude_non_gsb: bool = False,\nlimit: int = -1,\nsince: dt.date = dt.datetime(1970, 1, 1),\n) -&gt; list[Revision]:\n\"\"\"Retrieve a list of GSB-managed versions\n    Parameters\n    ----------\n    repo_root : Path\n        The directory where the repo should be created\n    tagged_only : bool, optional\n        By default, this method only returns tagged backups. To include\n        all available revisions, pass in `tagged_only=False`.\n    include_non_gsb : bool, optional\n        By default, this method excludes any revisions created outside of `gsb`.\n        To include all git commits and tags, pass in `include_non_gsb=True`.\n    limit : int, optional\n        By default, this method returns the entire history. To return only the\n        last _n_ revisions, pass in `limit=n`.\n    since : date or timestamp, optional\n        By default, this method returns the entire history. To return only\n        revisions made on or after a certain date, pass in `since=&lt;start_date&gt;`.\n    Returns\n    -------\n    list of dict\n        Metadata on the requested revisions, sorted in reverse-chronological\n        order\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/gsb/manifest/","title":"manifest","text":"<p>Configuration definition for an individual GSB-managed save</p>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest","title":"<code>Manifest</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Save-specific configuration</p> <p>Attributes:</p> Name Type Description <code>root</code> <code>Path</code> <p>The directory containing the save / repo</p> <code>patterns</code> <code>tuple of str</code> <p>The glob match-patterns that determine which files get tracked</p> Source code in <code>gsb/manifest.py</code> <pre><code>class Manifest(NamedTuple):\n\"\"\"Save-specific configuration\n    Attributes\n    ----------\n    root : Path\n        The directory containing the save / repo\n    patterns : tuple of str\n        The glob match-patterns that determine which files get tracked\n    \"\"\"\nroot: Path\npatterns: tuple[str, ...]\n@classmethod\ndef of(cls, repo_root: Path) -&gt; Self:\n\"\"\"Read the manifest of the specified GSB repo\n        Parameters\n        ----------\n        repo_root : Path\n            The root directory of the gsb-managed repo\n        Returns\n        -------\n        Manifest\n            the parsed manifest\n        Raises\n        ------\n        ValueError\n            If the configuration cannot be parsed\n        OSError\n            If the file does not exist or cannot otherwise be read\n        \"\"\"\nas_dict: dict[str, Any] = {\"root\": repo_root}\ncontents: _ManifestDict = tomllib.loads((repo_root / MANIFEST_NAME).read_text())\nfor key, value in contents.items():\nif key in Manifest._fields:\nif isinstance(value, list):\nvalue = tuple(value)\nas_dict[key] = value\nreturn cls(**as_dict)\ndef write(self) -&gt; None:\n\"\"\"Write the manifest to file, overwriting any existing configuration\n        Returns\n        -------\n        None\n        Notes\n        -----\n        The location and name of this file is controlled by the `root` attribute\n        and the `MANIFEST_NAME` constant, respectively, and cannot be overridden\n        Raises\n        ------\n        OSError\n            If the destination folder (`root`) does not exist or cannot be\n            written to\n        \"\"\"\nas_dict = {\n\"generated_by_gsb\": get_versions()[\"version\"],\n\"last_modified\": dt.datetime.now().isoformat(sep=\" \"),\n}\nfor attribute, value in self._asdict().items():\nif attribute == \"root\":\ncontinue\nas_dict[attribute] = value\nas_toml = _to_toml(as_dict)\n(self.root / MANIFEST_NAME).write_text(as_toml)\n</code></pre>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest.of","title":"<code>of(repo_root)</code>  <code>classmethod</code>","text":"<p>Read the manifest of the specified GSB repo</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The root directory of the gsb-managed repo</p> required <p>Returns:</p> Type Description <code>Manifest</code> <p>the parsed manifest</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration cannot be parsed</p> <code>OSError</code> <p>If the file does not exist or cannot otherwise be read</p> Source code in <code>gsb/manifest.py</code> <pre><code>@classmethod\ndef of(cls, repo_root: Path) -&gt; Self:\n\"\"\"Read the manifest of the specified GSB repo\n    Parameters\n    ----------\n    repo_root : Path\n        The root directory of the gsb-managed repo\n    Returns\n    -------\n    Manifest\n        the parsed manifest\n    Raises\n    ------\n    ValueError\n        If the configuration cannot be parsed\n    OSError\n        If the file does not exist or cannot otherwise be read\n    \"\"\"\nas_dict: dict[str, Any] = {\"root\": repo_root}\ncontents: _ManifestDict = tomllib.loads((repo_root / MANIFEST_NAME).read_text())\nfor key, value in contents.items():\nif key in Manifest._fields:\nif isinstance(value, list):\nvalue = tuple(value)\nas_dict[key] = value\nreturn cls(**as_dict)\n</code></pre>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest.write","title":"<code>write()</code>","text":"<p>Write the manifest to file, overwriting any existing configuration</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/gsb/manifest/#gsb.manifest.Manifest.write--notes","title":"Notes","text":"<p>The location and name of this file is controlled by the <code>root</code> attribute and the <code>MANIFEST_NAME</code> constant, respectively, and cannot be overridden</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the destination folder (<code>root</code>) does not exist or cannot be written to</p> Source code in <code>gsb/manifest.py</code> <pre><code>def write(self) -&gt; None:\n\"\"\"Write the manifest to file, overwriting any existing configuration\n    Returns\n    -------\n    None\n    Notes\n    -----\n    The location and name of this file is controlled by the `root` attribute\n    and the `MANIFEST_NAME` constant, respectively, and cannot be overridden\n    Raises\n    ------\n    OSError\n        If the destination folder (`root`) does not exist or cannot be\n        written to\n    \"\"\"\nas_dict = {\n\"generated_by_gsb\": get_versions()[\"version\"],\n\"last_modified\": dt.datetime.now().isoformat(sep=\" \"),\n}\nfor attribute, value in self._asdict().items():\nif attribute == \"root\":\ncontinue\nas_dict[attribute] = value\nas_toml = _to_toml(as_dict)\n(self.root / MANIFEST_NAME).write_text(as_toml)\n</code></pre>"},{"location":"reference/gsb/onboard/","title":"onboard","text":"<p>Functionality for onboarding a new save state</p>"},{"location":"reference/gsb/onboard/#gsb.onboard.create_repo","title":"<code>create_repo(repo_root, *patterns, ignore=None)</code>","text":"<p>Create a new <code>gsb</code>-managed git repo in the specified location</p> <p>Parameters:</p> Name Type Description Default <code>repo_root</code> <code>Path</code> <p>The directory where the repo should be created</p> required <code>patterns</code> <code>str</code> <p>List of glob-patterns to match, specifying what in the working directory should be archived. If none are provided, then it will be assumed that the intent is to back up the entire folder and all its contents.</p> <code>()</code> <code>ignore</code> <code>list of str</code> <p>List of glob-patterns to ignore. If None are specified, then nothing will be ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>Manifest</code> <p>The static configuration for that repo</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If there is already a <code>gsb</code> repo in that location</p> <code>OSError</code> <p>If <code>repo_root</code> does not exist, is not a directory or cannot be accessed</p> Source code in <code>gsb/onboard.py</code> <pre><code>def create_repo(\nrepo_root: Path, *patterns: str, ignore: Iterable[str] | None = None\n) -&gt; Manifest:\n\"\"\"Create a new `gsb`-managed git repo in the specified location\n    Parameters\n    ----------\n    repo_root : Path\n        The directory where the repo should be created\n    patterns : str\n        List of glob-patterns to match, specifying what in the working directory\n        should be archived. If none are provided, then it will be assumed that\n        the intent is to back up the *entire* folder and all its contents.\n    ignore : list of str, optional\n        List of glob-patterns to *ignore*. If None are specified, then nothing\n        will be ignored.\n    Returns\n    -------\n    Manifest\n        The static configuration for that repo\n    Raises\n    ------\n    FileExistsError\n        If there is already a `gsb` repo in that location\n    OSError\n        If `repo_root` does not exist, is not a directory or cannot be accessed\n    \"\"\"\nif (repo_root / MANIFEST_NAME).exists():\nraise FileExistsError(f\"{repo_root} already contains a GSB-managed repo\")\nif not patterns:\npatterns = (\".\",)\nif \".\" not in patterns:\npatterns = tuple(set(patterns))\n_git.init(repo_root)\n_update_gitignore(repo_root, ignore or ())\n# enforce round-trip\nManifest(repo_root, tuple(patterns)).write()\nmanifest = Manifest.of(repo_root)\n_git.add(repo_root, patterns)\n_git.force_add(repo_root, REQUIRED_FILES)\n_git.commit(repo_root, \"Started tracking with gsb\")\n_git.tag(repo_root, _generate_tag_name(), \"Start of gsb tracking\")\nreturn manifest\n</code></pre>"},{"location":"coverage/","title":"Coverage","text":""}]}